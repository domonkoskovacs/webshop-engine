/* tslint:disable */
/* eslint-disable */
/**
 * Webshop REST API
 * Store rest API.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AddressRequest
 */
export interface AddressRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressRequest
     */
    'country'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddressRequest
     */
    'zipCode': number;
    /**
     * 
     * @type {string}
     * @memberof AddressRequest
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressRequest
     */
    'street'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddressRequest
     */
    'streetNumber': number;
    /**
     * 
     * @type {string}
     * @memberof AddressRequest
     */
    'floorNumber'?: string;
}
/**
 * 
 * @export
 * @interface AddressResponse
 */
export interface AddressResponse {
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'country'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddressResponse
     */
    'zipCode'?: number;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'city'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'street'?: string;
    /**
     * 
     * @type {number}
     * @memberof AddressResponse
     */
    'streetNumber'?: number;
    /**
     * 
     * @type {string}
     * @memberof AddressResponse
     */
    'floorNumber'?: string;
}
/**
 * 
 * @export
 * @interface ArticleResponse
 */
export interface ArticleResponse {
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'buttonText'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'buttonLink'?: string;
    /**
     * 
     * @type {string}
     * @memberof ArticleResponse
     */
    'imageUrl'?: string;
}
/**
 * 
 * @export
 * @interface AuthorizationResponse
 */
export interface AuthorizationResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthorizationResponse
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationResponse
     */
    'role'?: AuthorizationResponseRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthorizationResponse
     */
    'tokenType'?: AuthorizationResponseTokenTypeEnum;
}

export const AuthorizationResponseRoleEnum = {
    Admin: 'ROLE_ADMIN',
    User: 'ROLE_USER',
    Monitoring: 'ROLE_MONITORING',
    Swagger: 'ROLE_SWAGGER'
} as const;

export type AuthorizationResponseRoleEnum = typeof AuthorizationResponseRoleEnum[keyof typeof AuthorizationResponseRoleEnum];
export const AuthorizationResponseTokenTypeEnum = {
    AccessToken: 'ACCESS_TOKEN',
    RefreshToken: 'REFRESH_TOKEN',
    InvalidToken: 'INVALID_TOKEN'
} as const;

export type AuthorizationResponseTokenTypeEnum = typeof AuthorizationResponseTokenTypeEnum[keyof typeof AuthorizationResponseTokenTypeEnum];

/**
 * 
 * @export
 * @interface BrandResponse
 */
export interface BrandResponse {
    /**
     * 
     * @type {string}
     * @memberof BrandResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof BrandResponse
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface CartItemRequest
 */
export interface CartItemRequest {
    /**
     * 
     * @type {string}
     * @memberof CartItemRequest
     */
    'productId': string;
    /**
     * 
     * @type {number}
     * @memberof CartItemRequest
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface CartItemResponse
 */
export interface CartItemResponse {
    /**
     * 
     * @type {ProductResponse}
     * @memberof CartItemResponse
     */
    'product'?: ProductResponse;
    /**
     * 
     * @type {number}
     * @memberof CartItemResponse
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface CategoryRequest
 */
export interface CategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof CategoryRequest
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface CategoryResponse
 */
export interface CategoryResponse {
    /**
     * 
     * @type {string}
     * @memberof CategoryResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CategoryResponse
     */
    'name'?: string;
    /**
     * 
     * @type {Array<SubCategoryResponse>}
     * @memberof CategoryResponse
     */
    'subCategories'?: Array<SubCategoryResponse>;
}
/**
 * 
 * @export
 * @interface CsvRequest
 */
export interface CsvRequest {
    /**
     * 
     * @type {string}
     * @memberof CsvRequest
     */
    'csv'?: string;
}
/**
 * 
 * @export
 * @interface CsvResponse
 */
export interface CsvResponse {
    /**
     * 
     * @type {string}
     * @memberof CsvResponse
     */
    'csv'?: string;
}
/**
 * 
 * @export
 * @interface CustomerTypeDistributionResponse
 */
export interface CustomerTypeDistributionResponse {
    /**
     * 
     * @type {number}
     * @memberof CustomerTypeDistributionResponse
     */
    'newCustomers'?: number;
    /**
     * 
     * @type {number}
     * @memberof CustomerTypeDistributionResponse
     */
    'returningCustomers'?: number;
}
/**
 * 
 * @export
 * @interface DeleteProductRequest
 */
export interface DeleteProductRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DeleteProductRequest
     */
    'ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Discount
 */
export interface Discount {
    /**
     * 
     * @type {string}
     * @memberof Discount
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof Discount
     */
    'discount'?: number;
}
/**
 * 
 * @export
 * @interface DiscountRequest
 */
export interface DiscountRequest {
    /**
     * 
     * @type {Array<Discount>}
     * @memberof DiscountRequest
     */
    'discounts'?: Array<Discount>;
}
/**
 * 
 * @export
 * @interface EmailRequest
 */
export interface EmailRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {Array<ResultEntry>}
     * @memberof ErrorResponse
     */
    'info'?: Array<ResultEntry>;
    /**
     * 
     * @type {Array<ResultEntry>}
     * @memberof ErrorResponse
     */
    'error'?: Array<ResultEntry>;
    /**
     * 
     * @type {Array<ResultEntry>}
     * @memberof ErrorResponse
     */
    'warning'?: Array<ResultEntry>;
}
/**
 * 
 * @export
 * @interface ForgottenPasswordRequest
 */
export interface ForgottenPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof ForgottenPasswordRequest
     */
    'email'?: string;
}
/**
 * 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'accessToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'accessTokenTimeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'refreshTokenTimeout'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'tokenType'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'role'?: string;
}
/**
 * 
 * @export
 * @interface NewPasswordRequest
 */
export interface NewPasswordRequest {
    /**
     * 
     * @type {string}
     * @memberof NewPasswordRequest
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof NewPasswordRequest
     */
    'password'?: string;
}
/**
 * 
 * @export
 * @interface OrderCountStatisticsResponse
 */
export interface OrderCountStatisticsResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderCountStatisticsResponse
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderCountStatisticsResponse
     */
    'totalOrderCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderCountStatisticsResponse
     */
    'completedOrderCount'?: number;
}
/**
 * 
 * @export
 * @interface OrderItemResponse
 */
export interface OrderItemResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderItemResponse
     */
    'productName'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderItemResponse
     */
    'individualPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderItemResponse
     */
    'thumbNailUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemResponse
     */
    'gender'?: OrderItemResponseGenderEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderItemResponse
     */
    'categoryName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemResponse
     */
    'subcategoryName'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderItemResponse
     */
    'productId'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderItemResponse
     */
    'count'?: number;
}

export const OrderItemResponseGenderEnum = {
    Men: 'MEN',
    Women: 'WOMEN',
    Unisex: 'UNISEX'
} as const;

export type OrderItemResponseGenderEnum = typeof OrderItemResponseGenderEnum[keyof typeof OrderItemResponseGenderEnum];

/**
 * 
 * @export
 * @interface OrderPageOrderResponse
 */
export interface OrderPageOrderResponse {
    /**
     * 
     * @type {Array<OrderResponse>}
     * @memberof OrderPageOrderResponse
     */
    'content'?: Array<OrderResponse>;
    /**
     * 
     * @type {PageableObject}
     * @memberof OrderPageOrderResponse
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {number}
     * @memberof OrderPageOrderResponse
     */
    'minPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderPageOrderResponse
     */
    'maxPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderPageOrderResponse
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrderPageOrderResponse
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderPageOrderResponse
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderPageOrderResponse
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderPageOrderResponse
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof OrderPageOrderResponse
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {boolean}
     * @memberof OrderPageOrderResponse
     */
    'first'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrderPageOrderResponse
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderPageOrderResponse
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface OrderPriceStatisticsResponse
 */
export interface OrderPriceStatisticsResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderPriceStatisticsResponse
     */
    'date'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderPriceStatisticsResponse
     */
    'totalOrderPriceSum'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderPriceStatisticsResponse
     */
    'completedOrderPriceSum'?: number;
}
/**
 * 
 * @export
 * @interface OrderResponse
 */
export interface OrderResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'orderDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'orderNumber'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'totalPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderResponse
     */
    'shippingPrice'?: number;
    /**
     * 
     * @type {AddressResponse}
     * @memberof OrderResponse
     */
    'address'?: AddressResponse;
    /**
     * 
     * @type {AddressResponse}
     * @memberof OrderResponse
     */
    'billingAddress'?: AddressResponse;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'paymentMethod'?: OrderResponsePaymentMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'status'?: OrderResponseStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'paidDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderResponse
     */
    'refundedDate'?: string;
    /**
     * 
     * @type {Array<OrderItemResponse>}
     * @memberof OrderResponse
     */
    'items'?: Array<OrderItemResponse>;
}

export const OrderResponsePaymentMethodEnum = {
    Stripe: 'STRIPE'
} as const;

export type OrderResponsePaymentMethodEnum = typeof OrderResponsePaymentMethodEnum[keyof typeof OrderResponsePaymentMethodEnum];
export const OrderResponseStatusEnum = {
    Created: 'CREATED',
    PaymentFailed: 'PAYMENT_FAILED',
    Paid: 'PAID',
    Processing: 'PROCESSING',
    Packaged: 'PACKAGED',
    Shipping: 'SHIPPING',
    Delivered: 'DELIVERED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    WaitingForRefund: 'WAITING_FOR_REFUND',
    Refunded: 'REFUNDED',
    ReturnRequested: 'RETURN_REQUESTED',
    ReturnApproved: 'RETURN_APPROVED',
    ReturnReceived: 'RETURN_RECEIVED',
    ReturnCompleted: 'RETURN_COMPLETED',
    ReturnRejected: 'RETURN_REJECTED'
} as const;

export type OrderResponseStatusEnum = typeof OrderResponseStatusEnum[keyof typeof OrderResponseStatusEnum];

/**
 * 
 * @export
 * @interface OrderStatusDistributionResponse
 */
export interface OrderStatusDistributionResponse {
    /**
     * 
     * @type {number}
     * @memberof OrderStatusDistributionResponse
     */
    'pendingOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderStatusDistributionResponse
     */
    'processingOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderStatusDistributionResponse
     */
    'shippedOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderStatusDistributionResponse
     */
    'returnedOrders'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderStatusDistributionResponse
     */
    'cancelledOrders'?: number;
}
/**
 * 
 * @export
 * @interface OrderStatusRequest
 */
export interface OrderStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderStatusRequest
     */
    'orderStatus': OrderStatusRequestOrderStatusEnum;
}

export const OrderStatusRequestOrderStatusEnum = {
    Created: 'CREATED',
    PaymentFailed: 'PAYMENT_FAILED',
    Paid: 'PAID',
    Processing: 'PROCESSING',
    Packaged: 'PACKAGED',
    Shipping: 'SHIPPING',
    Delivered: 'DELIVERED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    WaitingForRefund: 'WAITING_FOR_REFUND',
    Refunded: 'REFUNDED',
    ReturnRequested: 'RETURN_REQUESTED',
    ReturnApproved: 'RETURN_APPROVED',
    ReturnReceived: 'RETURN_RECEIVED',
    ReturnCompleted: 'RETURN_COMPLETED',
    ReturnRejected: 'RETURN_REJECTED'
} as const;

export type OrderStatusRequestOrderStatusEnum = typeof OrderStatusRequestOrderStatusEnum[keyof typeof OrderStatusRequestOrderStatusEnum];

/**
 * 
 * @export
 * @interface PageableObject
 */
export interface PageableObject {
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'offset'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageableObject
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageSize'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'paged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'unpaged'?: boolean;
}
/**
 * 
 * @export
 * @interface PaymentIntentResponse
 */
export interface PaymentIntentResponse {
    /**
     * 
     * @type {string}
     * @memberof PaymentIntentResponse
     */
    'clientSecret'?: string;
}
/**
 * 
 * @export
 * @interface ProductPageProductResponse
 */
export interface ProductPageProductResponse {
    /**
     * 
     * @type {Array<ProductResponse>}
     * @memberof ProductPageProductResponse
     */
    'content'?: Array<ProductResponse>;
    /**
     * 
     * @type {PageableObject}
     * @memberof ProductPageProductResponse
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {number}
     * @memberof ProductPageProductResponse
     */
    'minPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductPageProductResponse
     */
    'maxPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductPageProductResponse
     */
    'minDiscount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductPageProductResponse
     */
    'maxDiscount'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProductPageProductResponse
     */
    'last'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductPageProductResponse
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductPageProductResponse
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductPageProductResponse
     */
    'size'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductPageProductResponse
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof ProductPageProductResponse
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {boolean}
     * @memberof ProductPageProductResponse
     */
    'first'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProductPageProductResponse
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ProductPageProductResponse
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductResponse
 */
export interface ProductResponse {
    /**
     * 
     * @type {string}
     * @memberof ProductResponse
     */
    'id'?: string;
    /**
     * 
     * @type {BrandResponse}
     * @memberof ProductResponse
     */
    'brand'?: BrandResponse;
    /**
     * 
     * @type {string}
     * @memberof ProductResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductResponse
     */
    'description'?: string;
    /**
     * 
     * @type {CategoryResponse}
     * @memberof ProductResponse
     */
    'category'?: CategoryResponse;
    /**
     * 
     * @type {SubCategoryResponse}
     * @memberof ProductResponse
     */
    'subCategory'?: SubCategoryResponse;
    /**
     * 
     * @type {string}
     * @memberof ProductResponse
     */
    'gender'?: ProductResponseGenderEnum;
    /**
     * 
     * @type {number}
     * @memberof ProductResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductResponse
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProductResponse
     */
    'discountPercentage'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductResponse
     */
    'imageUrls'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductResponse
     */
    'itemNumber'?: string;
}

export const ProductResponseGenderEnum = {
    Men: 'MEN',
    Women: 'WOMEN',
    Unisex: 'UNISEX'
} as const;

export type ProductResponseGenderEnum = typeof ProductResponseGenderEnum[keyof typeof ProductResponseGenderEnum];

/**
 * 
 * @export
 * @interface ProductStatisticsResponse
 */
export interface ProductStatisticsResponse {
    /**
     * 
     * @type {ProductResponse}
     * @memberof ProductStatisticsResponse
     */
    'product'?: ProductResponse;
    /**
     * 
     * @type {number}
     * @memberof ProductStatisticsResponse
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface PromotionEmailRequest
 */
export interface PromotionEmailRequest {
    /**
     * 
     * @type {string}
     * @memberof PromotionEmailRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionEmailRequest
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionEmailRequest
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionEmailRequest
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromotionEmailRequest
     */
    'dayOfWeek': Array<PromotionEmailRequestDayOfWeekEnum>;
    /**
     * 
     * @type {number}
     * @memberof PromotionEmailRequest
     */
    'hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof PromotionEmailRequest
     */
    'minute'?: number;
}

export const PromotionEmailRequestDayOfWeekEnum = {
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY',
    Sunday: 'SUNDAY'
} as const;

export type PromotionEmailRequestDayOfWeekEnum = typeof PromotionEmailRequestDayOfWeekEnum[keyof typeof PromotionEmailRequestDayOfWeekEnum];

/**
 * 
 * @export
 * @interface PromotionEmailResponse
 */
export interface PromotionEmailResponse {
    /**
     * 
     * @type {string}
     * @memberof PromotionEmailResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionEmailResponse
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionEmailResponse
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionEmailResponse
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromotionEmailResponse
     */
    'imageUrl'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PromotionEmailResponse
     */
    'dayOfWeek'?: Array<PromotionEmailResponseDayOfWeekEnum>;
    /**
     * 
     * @type {number}
     * @memberof PromotionEmailResponse
     */
    'hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof PromotionEmailResponse
     */
    'minute'?: number;
}

export const PromotionEmailResponseDayOfWeekEnum = {
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY',
    Sunday: 'SUNDAY'
} as const;

export type PromotionEmailResponseDayOfWeekEnum = typeof PromotionEmailResponseDayOfWeekEnum[keyof typeof PromotionEmailResponseDayOfWeekEnum];

/**
 * 
 * @export
 * @interface PublicStoreResponse
 */
export interface PublicStoreResponse {
    /**
     * 
     * @type {string}
     * @memberof PublicStoreResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof PublicStoreResponse
     */
    'minOrderPrice': number;
    /**
     * 
     * @type {number}
     * @memberof PublicStoreResponse
     */
    'shippingPrice': number;
    /**
     * 
     * @type {number}
     * @memberof PublicStoreResponse
     */
    'returnPeriod': number;
}
/**
 * 
 * @export
 * @interface RefundOrderItemRequest
 */
export interface RefundOrderItemRequest {
    /**
     * 
     * @type {string}
     * @memberof RefundOrderItemRequest
     */
    'orderItemId': string;
    /**
     * 
     * @type {number}
     * @memberof RefundOrderItemRequest
     */
    'count': number;
}
/**
 * 
 * @export
 * @interface RegistrationRequest
 */
export interface RegistrationRequest {
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationRequest
     */
    'gender'?: RegistrationRequestGenderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof RegistrationRequest
     */
    'subscribedToEmail'?: boolean;
}

export const RegistrationRequestGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE'
} as const;

export type RegistrationRequestGenderEnum = typeof RegistrationRequestGenderEnum[keyof typeof RegistrationRequestGenderEnum];

/**
 * 
 * @export
 * @interface ResultEntry
 */
export interface ResultEntry {
    /**
     * 
     * @type {number}
     * @memberof ResultEntry
     */
    'ReasonStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof ResultEntry
     */
    'reasonCode'?: ResultEntryReasonCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof ResultEntry
     */
    'message'?: string;
}

export const ResultEntryReasonCodeEnum = {
    InternalServerError: 'INTERNAL_SERVER_ERROR',
    TechnicalError: 'TECHNICAL_ERROR',
    ValidationError: 'VALIDATION_ERROR',
    BadCredentialsError: 'BAD_CREDENTIALS_ERROR',
    JwtExpiredError: 'JWT_EXPIRED_ERROR',
    BadTokenFormatError: 'BAD_TOKEN_FORMAT_ERROR',
    UnverifiedUser: 'UNVERIFIED_USER',
    AlreadyVerifiedUser: 'ALREADY_VERIFIED_USER',
    BadRefreshToken: 'BAD_REFRESH_TOKEN',
    EmailTaken: 'EMAIL_TAKEN',
    UnauthenticatedUser: 'UNAUTHENTICATED_USER',
    BadToken: 'BAD_TOKEN',
    AccessDenied: 'ACCESS_DENIED',
    WrongPassword: 'WRONG_PASSWORD',
    EmailNotExists: 'EMAIL_NOT_EXISTS',
    EmailException: 'EMAIL_EXCEPTION',
    ImageException: 'IMAGE_EXCEPTION',
    StripeException: 'STRIPE_EXCEPTION',
    OrderException: 'ORDER_EXCEPTION',
    NotFound: 'NOT_FOUND',
    NoShippingAddress: 'NO_SHIPPING_ADDRESS',
    NoBillingAddress: 'NO_BILLING_ADDRESS',
    NoItemsInCart: 'NO_ITEMS_IN_CART',
    NotEnoughProductInStock: 'NOT_ENOUGH_PRODUCT_IN_STOCK',
    InvalidOrderPrice: 'INVALID_ORDER_PRICE',
    CsvError: 'CSV_ERROR',
    CsvUploadError: 'CSV_UPLOAD_ERROR',
    OrderNotReturnable: 'ORDER_NOT_RETURNABLE',
    ExpiredReturnPeriod: 'EXPIRED_RETURN_PERIOD',
    PromotionEmailNameOccupied: 'PROMOTION_EMAIL_NAME_OCCUPIED'
} as const;

export type ResultEntryReasonCodeEnum = typeof ResultEntryReasonCodeEnum[keyof typeof ResultEntryReasonCodeEnum];

/**
 * 
 * @export
 * @interface SortObject
 */
export interface SortObject {
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'empty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'sorted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'unsorted'?: boolean;
}
/**
 * 
 * @export
 * @interface StatisticsResponse
 */
export interface StatisticsResponse {
    /**
     * 
     * @type {Array<ProductStatisticsResponse>}
     * @memberof StatisticsResponse
     */
    'mostSavedProducts'?: Array<ProductStatisticsResponse>;
    /**
     * 
     * @type {Array<ProductStatisticsResponse>}
     * @memberof StatisticsResponse
     */
    'mostOrderedProducts'?: Array<ProductStatisticsResponse>;
    /**
     * 
     * @type {Array<ProductStatisticsResponse>}
     * @memberof StatisticsResponse
     */
    'mostReturnedProducts'?: Array<ProductStatisticsResponse>;
    /**
     * 
     * @type {Array<UserStatisticsResponse>}
     * @memberof StatisticsResponse
     */
    'topSpendingUsers'?: Array<UserStatisticsResponse>;
    /**
     * 
     * @type {Array<UserStatisticsResponse>}
     * @memberof StatisticsResponse
     */
    'topOrderingUsers'?: Array<UserStatisticsResponse>;
    /**
     * 
     * @type {Array<OrderCountStatisticsResponse>}
     * @memberof StatisticsResponse
     */
    'orderCounts'?: Array<OrderCountStatisticsResponse>;
    /**
     * 
     * @type {Array<OrderPriceStatisticsResponse>}
     * @memberof StatisticsResponse
     */
    'orderPrices'?: Array<OrderPriceStatisticsResponse>;
    /**
     * 
     * @type {Array<WeeklyOrderStatisticsResponse>}
     * @memberof StatisticsResponse
     */
    'orderByDayOfWeek'?: Array<WeeklyOrderStatisticsResponse>;
    /**
     * 
     * @type {CustomerTypeDistributionResponse}
     * @memberof StatisticsResponse
     */
    'customerTypeDistribution'?: CustomerTypeDistributionResponse;
    /**
     * 
     * @type {OrderStatusDistributionResponse}
     * @memberof StatisticsResponse
     */
    'orderStatusDistribution'?: OrderStatusDistributionResponse;
    /**
     * 
     * @type {number}
     * @memberof StatisticsResponse
     */
    'averageOrderValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatisticsResponse
     */
    'totalRevenue'?: number;
    /**
     * 
     * @type {number}
     * @memberof StatisticsResponse
     */
    'totalShippingCost'?: number;
}
/**
 * 
 * @export
 * @interface StoreRequest
 */
export interface StoreRequest {
    /**
     * 
     * @type {string}
     * @memberof StoreRequest
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof StoreRequest
     */
    'minOrderPrice': number;
    /**
     * 
     * @type {number}
     * @memberof StoreRequest
     */
    'shippingPrice': number;
    /**
     * 
     * @type {number}
     * @memberof StoreRequest
     */
    'returnPeriod': number;
    /**
     * 
     * @type {number}
     * @memberof StoreRequest
     */
    'unpaidOrderCancelHours': number;
    /**
     * 
     * @type {string}
     * @memberof StoreRequest
     */
    'theme'?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreRequest
     */
    'primaryColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreRequest
     */
    'secondaryColor'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StoreRequest
     */
    'deleteOutOfStockProducts': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoreRequest
     */
    'deleteUnusedPictures': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoreRequest
     */
    'enableBuiltInMarketingEmails': boolean;
}
/**
 * 
 * @export
 * @interface StoreResponse
 */
export interface StoreResponse {
    /**
     * 
     * @type {string}
     * @memberof StoreResponse
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof StoreResponse
     */
    'minOrderPrice': number;
    /**
     * 
     * @type {number}
     * @memberof StoreResponse
     */
    'shippingPrice': number;
    /**
     * 
     * @type {number}
     * @memberof StoreResponse
     */
    'returnPeriod': number;
    /**
     * 
     * @type {number}
     * @memberof StoreResponse
     */
    'unpaidOrderCancelHours': number;
    /**
     * 
     * @type {string}
     * @memberof StoreResponse
     */
    'theme'?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponse
     */
    'primaryColor'?: string;
    /**
     * 
     * @type {string}
     * @memberof StoreResponse
     */
    'secondaryColor'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StoreResponse
     */
    'deleteOutOfStockProducts': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoreResponse
     */
    'deleteUnusedPictures': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StoreResponse
     */
    'enableBuiltInMarketingEmails': boolean;
}
/**
 * 
 * @export
 * @interface SubCategoryResponse
 */
export interface SubCategoryResponse {
    /**
     * 
     * @type {string}
     * @memberof SubCategoryResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SubCategoryResponse
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TokenRequest
 */
export interface TokenRequest {
    /**
     * 
     * @type {string}
     * @memberof TokenRequest
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'gender'?: UpdateUserRequestGenderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'subscribedToEmail'?: boolean;
    /**
     * 
     * @type {AddressRequest}
     * @memberof UpdateUserRequest
     */
    'shippingAddress'?: AddressRequest;
    /**
     * 
     * @type {AddressRequest}
     * @memberof UpdateUserRequest
     */
    'billingAddress'?: AddressRequest;
}

export const UpdateUserRequestGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE'
} as const;

export type UpdateUserRequestGenderEnum = typeof UpdateUserRequestGenderEnum[keyof typeof UpdateUserRequestGenderEnum];

/**
 * 
 * @export
 * @interface UserResponse
 */
export interface UserResponse {
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'firstname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'lastname'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'role'?: UserResponseRoleEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'verified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'phoneNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserResponse
     */
    'gender'?: UserResponseGenderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UserResponse
     */
    'subscribedToEmail'?: boolean;
    /**
     * 
     * @type {AddressResponse}
     * @memberof UserResponse
     */
    'shippingAddress'?: AddressResponse;
    /**
     * 
     * @type {AddressResponse}
     * @memberof UserResponse
     */
    'billingAddress'?: AddressResponse;
    /**
     * 
     * @type {Array<CartItemResponse>}
     * @memberof UserResponse
     */
    'cart'?: Array<CartItemResponse>;
    /**
     * 
     * @type {Array<ProductResponse>}
     * @memberof UserResponse
     */
    'saved'?: Array<ProductResponse>;
    /**
     * 
     * @type {Array<OrderResponse>}
     * @memberof UserResponse
     */
    'orders'?: Array<OrderResponse>;
}

export const UserResponseRoleEnum = {
    Admin: 'ROLE_ADMIN',
    User: 'ROLE_USER',
    Monitoring: 'ROLE_MONITORING',
    Swagger: 'ROLE_SWAGGER'
} as const;

export type UserResponseRoleEnum = typeof UserResponseRoleEnum[keyof typeof UserResponseRoleEnum];
export const UserResponseGenderEnum = {
    Male: 'MALE',
    Female: 'FEMALE'
} as const;

export type UserResponseGenderEnum = typeof UserResponseGenderEnum[keyof typeof UserResponseGenderEnum];

/**
 * 
 * @export
 * @interface UserStatisticsResponse
 */
export interface UserStatisticsResponse {
    /**
     * 
     * @type {string}
     * @memberof UserStatisticsResponse
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserStatisticsResponse
     */
    'fullName'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserStatisticsResponse
     */
    'amount'?: number;
}
/**
 * 
 * @export
 * @interface VerificationRequest
 */
export interface VerificationRequest {
    /**
     * 
     * @type {string}
     * @memberof VerificationRequest
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface WeeklyOrderStatisticsResponse
 */
export interface WeeklyOrderStatisticsResponse {
    /**
     * 
     * @type {string}
     * @memberof WeeklyOrderStatisticsResponse
     */
    'dayOfWeek'?: WeeklyOrderStatisticsResponseDayOfWeekEnum;
    /**
     * 
     * @type {number}
     * @memberof WeeklyOrderStatisticsResponse
     */
    'orderCount'?: number;
}

export const WeeklyOrderStatisticsResponseDayOfWeekEnum = {
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY',
    Sunday: 'SUNDAY'
} as const;

export type WeeklyOrderStatisticsResponseDayOfWeekEnum = typeof WeeklyOrderStatisticsResponseDayOfWeekEnum[keyof typeof WeeklyOrderStatisticsResponseDayOfWeekEnum];


/**
 * ArticleServiceApi - axios parameter creator
 * @export
 */
export const ArticleServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Administrator creates a new article
         * @summary Create a new article
         * @param {File} image 
         * @param {string} [name] 
         * @param {string} [text] 
         * @param {string} [buttonText] 
         * @param {string} [buttonLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4: async (image: File, name?: string, text?: string, buttonText?: string, buttonLink?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('create4', 'image', image)
            const localVarPath = `/api/article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (text !== undefined) { 
                localVarFormParams.append('text', text as any);
            }
    
            if (buttonText !== undefined) { 
                localVarFormParams.append('buttonText', buttonText as any);
            }
    
            if (buttonLink !== undefined) { 
                localVarFormParams.append('buttonLink', buttonLink as any);
            }
    
            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Administrator can delete an article
         * @summary Delete an article
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete3', 'id', id)
            const localVarPath = `/api/article/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an article by id
         * @summary Get an article
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('get1', 'id', id)
            const localVarPath = `/api/article/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all article
         * @summary Get all article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll3: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/article`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ArticleServiceApi - functional programming interface
 * @export
 */
export const ArticleServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ArticleServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Administrator creates a new article
         * @summary Create a new article
         * @param {File} image 
         * @param {string} [name] 
         * @param {string} [text] 
         * @param {string} [buttonText] 
         * @param {string} [buttonLink] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create4(image: File, name?: string, text?: string, buttonText?: string, buttonLink?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create4(image, name, text, buttonText, buttonLink, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticleServiceApi.create4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Administrator can delete an article
         * @summary Delete an article
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete3(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete3(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticleServiceApi.delete3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get an article by id
         * @summary Get an article
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ArticleResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticleServiceApi.get1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all article
         * @summary Get all article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll3(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArticleResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll3(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ArticleServiceApi.getAll3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ArticleServiceApi - factory interface
 * @export
 */
export const ArticleServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ArticleServiceApiFp(configuration)
    return {
        /**
         * Administrator creates a new article
         * @summary Create a new article
         * @param {ArticleServiceApiCreate4Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create4(requestParameters: ArticleServiceApiCreate4Request, options?: RawAxiosRequestConfig): AxiosPromise<ArticleResponse> {
            return localVarFp.create4(requestParameters.image, requestParameters.name, requestParameters.text, requestParameters.buttonText, requestParameters.buttonLink, options).then((request) => request(axios, basePath));
        },
        /**
         * Administrator can delete an article
         * @summary Delete an article
         * @param {ArticleServiceApiDelete3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete3(requestParameters: ArticleServiceApiDelete3Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete3(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an article by id
         * @summary Get an article
         * @param {ArticleServiceApiGet1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get1(requestParameters: ArticleServiceApiGet1Request, options?: RawAxiosRequestConfig): AxiosPromise<ArticleResponse> {
            return localVarFp.get1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all article
         * @summary Get all article
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll3(options?: RawAxiosRequestConfig): AxiosPromise<Array<ArticleResponse>> {
            return localVarFp.getAll3(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create4 operation in ArticleServiceApi.
 * @export
 * @interface ArticleServiceApiCreate4Request
 */
export interface ArticleServiceApiCreate4Request {
    /**
     * 
     * @type {File}
     * @memberof ArticleServiceApiCreate4
     */
    readonly image: File

    /**
     * 
     * @type {string}
     * @memberof ArticleServiceApiCreate4
     */
    readonly name?: string

    /**
     * 
     * @type {string}
     * @memberof ArticleServiceApiCreate4
     */
    readonly text?: string

    /**
     * 
     * @type {string}
     * @memberof ArticleServiceApiCreate4
     */
    readonly buttonText?: string

    /**
     * 
     * @type {string}
     * @memberof ArticleServiceApiCreate4
     */
    readonly buttonLink?: string
}

/**
 * Request parameters for delete3 operation in ArticleServiceApi.
 * @export
 * @interface ArticleServiceApiDelete3Request
 */
export interface ArticleServiceApiDelete3Request {
    /**
     * 
     * @type {string}
     * @memberof ArticleServiceApiDelete3
     */
    readonly id: string
}

/**
 * Request parameters for get1 operation in ArticleServiceApi.
 * @export
 * @interface ArticleServiceApiGet1Request
 */
export interface ArticleServiceApiGet1Request {
    /**
     * 
     * @type {string}
     * @memberof ArticleServiceApiGet1
     */
    readonly id: string
}

/**
 * ArticleServiceApi - object-oriented interface
 * @export
 * @class ArticleServiceApi
 * @extends {BaseAPI}
 */
export class ArticleServiceApi extends BaseAPI {
    /**
     * Administrator creates a new article
     * @summary Create a new article
     * @param {ArticleServiceApiCreate4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleServiceApi
     */
    public create4(requestParameters: ArticleServiceApiCreate4Request, options?: RawAxiosRequestConfig) {
        return ArticleServiceApiFp(this.configuration).create4(requestParameters.image, requestParameters.name, requestParameters.text, requestParameters.buttonText, requestParameters.buttonLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Administrator can delete an article
     * @summary Delete an article
     * @param {ArticleServiceApiDelete3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleServiceApi
     */
    public delete3(requestParameters: ArticleServiceApiDelete3Request, options?: RawAxiosRequestConfig) {
        return ArticleServiceApiFp(this.configuration).delete3(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an article by id
     * @summary Get an article
     * @param {ArticleServiceApiGet1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleServiceApi
     */
    public get1(requestParameters: ArticleServiceApiGet1Request, options?: RawAxiosRequestConfig) {
        return ArticleServiceApiFp(this.configuration).get1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all article
     * @summary Get all article
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ArticleServiceApi
     */
    public getAll3(options?: RawAxiosRequestConfig) {
        return ArticleServiceApiFp(this.configuration).getAll3(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthServiceApi - axios parameter creator
 * @export
 */
export const AuthServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * An access token can be authorized, and the user id can be extracted
         * @summary Authorization of an access token
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (tokenRequest: TokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequest' is not null or undefined
            assertParamExists('authorize', 'tokenRequest', tokenRequest)
            const localVarPath = `/api/auth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can login with username and password and get an access token
         * @summary Login with an existing user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('login', 'loginRequest', loginRequest)
            const localVarPath = `/api/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can refresh their access token with a refresh token
         * @summary Refresh access token
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (tokenRequest: TokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tokenRequest' is not null or undefined
            assertParamExists('refreshToken', 'tokenRequest', tokenRequest)
            const localVarPath = `/api/auth/refreshToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthServiceApi - functional programming interface
 * @export
 */
export const AuthServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * An access token can be authorized, and the user id can be extracted
         * @summary Authorization of an access token
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(tokenRequest: TokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthorizationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(tokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.authorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Users can login with username and password and get an access token
         * @summary Login with an existing user
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.login']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Users can refresh their access token with a refresh token
         * @summary Refresh access token
         * @param {TokenRequest} tokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(tokenRequest: TokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(tokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthServiceApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthServiceApi - factory interface
 * @export
 */
export const AuthServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthServiceApiFp(configuration)
    return {
        /**
         * An access token can be authorized, and the user id can be extracted
         * @summary Authorization of an access token
         * @param {AuthServiceApiAuthorizeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(requestParameters: AuthServiceApiAuthorizeRequest, options?: RawAxiosRequestConfig): AxiosPromise<AuthorizationResponse> {
            return localVarFp.authorize(requestParameters.tokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can login with username and password and get an access token
         * @summary Login with an existing user
         * @param {AuthServiceApiLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(requestParameters: AuthServiceApiLoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.login(requestParameters.loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can refresh their access token with a refresh token
         * @summary Refresh access token
         * @param {AuthServiceApiRefreshTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(requestParameters: AuthServiceApiRefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.refreshToken(requestParameters.tokenRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authorize operation in AuthServiceApi.
 * @export
 * @interface AuthServiceApiAuthorizeRequest
 */
export interface AuthServiceApiAuthorizeRequest {
    /**
     * 
     * @type {TokenRequest}
     * @memberof AuthServiceApiAuthorize
     */
    readonly tokenRequest: TokenRequest
}

/**
 * Request parameters for login operation in AuthServiceApi.
 * @export
 * @interface AuthServiceApiLoginRequest
 */
export interface AuthServiceApiLoginRequest {
    /**
     * 
     * @type {LoginRequest}
     * @memberof AuthServiceApiLogin
     */
    readonly loginRequest: LoginRequest
}

/**
 * Request parameters for refreshToken operation in AuthServiceApi.
 * @export
 * @interface AuthServiceApiRefreshTokenRequest
 */
export interface AuthServiceApiRefreshTokenRequest {
    /**
     * 
     * @type {TokenRequest}
     * @memberof AuthServiceApiRefreshToken
     */
    readonly tokenRequest: TokenRequest
}

/**
 * AuthServiceApi - object-oriented interface
 * @export
 * @class AuthServiceApi
 * @extends {BaseAPI}
 */
export class AuthServiceApi extends BaseAPI {
    /**
     * An access token can be authorized, and the user id can be extracted
     * @summary Authorization of an access token
     * @param {AuthServiceApiAuthorizeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceApi
     */
    public authorize(requestParameters: AuthServiceApiAuthorizeRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).authorize(requestParameters.tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can login with username and password and get an access token
     * @summary Login with an existing user
     * @param {AuthServiceApiLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceApi
     */
    public login(requestParameters: AuthServiceApiLoginRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).login(requestParameters.loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can refresh their access token with a refresh token
     * @summary Refresh access token
     * @param {AuthServiceApiRefreshTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthServiceApi
     */
    public refreshToken(requestParameters: AuthServiceApiRefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthServiceApiFp(this.configuration).refreshToken(requestParameters.tokenRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CategoryServiceApi - axios parameter creator
 * @export
 */
export const CategoryServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Admins can delete a category
         * @summary Delete a category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/api/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can add a subcategory to a category
         * @summary Add a subcategory to a category
         * @param {string} id 
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubCategory: async (id: string, categoryRequest: CategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addSubCategory', 'id', id)
            // verify required parameter 'categoryRequest' is not null or undefined
            assertParamExists('addSubCategory', 'categoryRequest', categoryRequest)
            const localVarPath = `/api/category/subCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can create a category
         * @summary Create a category
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3: async (categoryRequest: CategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryRequest' is not null or undefined
            assertParamExists('create3', 'categoryRequest', categoryRequest)
            const localVarPath = `/api/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can delete a subcategory
         * @summary Delete a subcategory
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubCategory: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSubCategory', 'id', id)
            const localVarPath = `/api/category/subCategory/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Public endpoint returns all categories
         * @summary Get all category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll2: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/category`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Public endpoint returns a category
         * @summary Get a category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById1', 'id', id)
            const localVarPath = `/api/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can update a category
         * @summary Update a category
         * @param {string} id 
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1: async (id: string, categoryRequest: CategoryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update1', 'id', id)
            // verify required parameter 'categoryRequest' is not null or undefined
            assertParamExists('update1', 'categoryRequest', categoryRequest)
            const localVarPath = `/api/category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(categoryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryServiceApi - functional programming interface
 * @export
 */
export const CategoryServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoryServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Admins can delete a category
         * @summary Delete a category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryServiceApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can add a subcategory to a category
         * @summary Add a subcategory to a category
         * @param {string} id 
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSubCategory(id: string, categoryRequest: CategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSubCategory(id, categoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryServiceApi.addSubCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can create a category
         * @summary Create a category
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create3(categoryRequest: CategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create3(categoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryServiceApi.create3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can delete a subcategory
         * @summary Delete a subcategory
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSubCategory(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSubCategory(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryServiceApi.deleteSubCategory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Public endpoint returns all categories
         * @summary Get all category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll2(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CategoryResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll2(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryServiceApi.getAll2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Public endpoint returns a category
         * @summary Get a category
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById1(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById1(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryServiceApi.getById1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can update a category
         * @summary Update a category
         * @param {string} id 
         * @param {CategoryRequest} categoryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update1(id: string, categoryRequest: CategoryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CategoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update1(id, categoryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['CategoryServiceApi.update1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * CategoryServiceApi - factory interface
 * @export
 */
export const CategoryServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoryServiceApiFp(configuration)
    return {
        /**
         * Admins can delete a category
         * @summary Delete a category
         * @param {CategoryServiceApiDeleteRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(requestParameters: CategoryServiceApiDeleteRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._delete(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can add a subcategory to a category
         * @summary Add a subcategory to a category
         * @param {CategoryServiceApiAddSubCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubCategory(requestParameters: CategoryServiceApiAddSubCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.addSubCategory(requestParameters.id, requestParameters.categoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can create a category
         * @summary Create a category
         * @param {CategoryServiceApiCreate3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create3(requestParameters: CategoryServiceApiCreate3Request, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.create3(requestParameters.categoryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can delete a subcategory
         * @summary Delete a subcategory
         * @param {CategoryServiceApiDeleteSubCategoryRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubCategory(requestParameters: CategoryServiceApiDeleteSubCategoryRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteSubCategory(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Public endpoint returns all categories
         * @summary Get all category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll2(options?: RawAxiosRequestConfig): AxiosPromise<Array<CategoryResponse>> {
            return localVarFp.getAll2(options).then((request) => request(axios, basePath));
        },
        /**
         * Public endpoint returns a category
         * @summary Get a category
         * @param {CategoryServiceApiGetById1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById1(requestParameters: CategoryServiceApiGetById1Request, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.getById1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can update a category
         * @summary Update a category
         * @param {CategoryServiceApiUpdate1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update1(requestParameters: CategoryServiceApiUpdate1Request, options?: RawAxiosRequestConfig): AxiosPromise<CategoryResponse> {
            return localVarFp.update1(requestParameters.id, requestParameters.categoryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _delete operation in CategoryServiceApi.
 * @export
 * @interface CategoryServiceApiDeleteRequest
 */
export interface CategoryServiceApiDeleteRequest {
    /**
     * 
     * @type {string}
     * @memberof CategoryServiceApiDelete
     */
    readonly id: string
}

/**
 * Request parameters for addSubCategory operation in CategoryServiceApi.
 * @export
 * @interface CategoryServiceApiAddSubCategoryRequest
 */
export interface CategoryServiceApiAddSubCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof CategoryServiceApiAddSubCategory
     */
    readonly id: string

    /**
     * 
     * @type {CategoryRequest}
     * @memberof CategoryServiceApiAddSubCategory
     */
    readonly categoryRequest: CategoryRequest
}

/**
 * Request parameters for create3 operation in CategoryServiceApi.
 * @export
 * @interface CategoryServiceApiCreate3Request
 */
export interface CategoryServiceApiCreate3Request {
    /**
     * 
     * @type {CategoryRequest}
     * @memberof CategoryServiceApiCreate3
     */
    readonly categoryRequest: CategoryRequest
}

/**
 * Request parameters for deleteSubCategory operation in CategoryServiceApi.
 * @export
 * @interface CategoryServiceApiDeleteSubCategoryRequest
 */
export interface CategoryServiceApiDeleteSubCategoryRequest {
    /**
     * 
     * @type {string}
     * @memberof CategoryServiceApiDeleteSubCategory
     */
    readonly id: string
}

/**
 * Request parameters for getById1 operation in CategoryServiceApi.
 * @export
 * @interface CategoryServiceApiGetById1Request
 */
export interface CategoryServiceApiGetById1Request {
    /**
     * 
     * @type {string}
     * @memberof CategoryServiceApiGetById1
     */
    readonly id: string
}

/**
 * Request parameters for update1 operation in CategoryServiceApi.
 * @export
 * @interface CategoryServiceApiUpdate1Request
 */
export interface CategoryServiceApiUpdate1Request {
    /**
     * 
     * @type {string}
     * @memberof CategoryServiceApiUpdate1
     */
    readonly id: string

    /**
     * 
     * @type {CategoryRequest}
     * @memberof CategoryServiceApiUpdate1
     */
    readonly categoryRequest: CategoryRequest
}

/**
 * CategoryServiceApi - object-oriented interface
 * @export
 * @class CategoryServiceApi
 * @extends {BaseAPI}
 */
export class CategoryServiceApi extends BaseAPI {
    /**
     * Admins can delete a category
     * @summary Delete a category
     * @param {CategoryServiceApiDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryServiceApi
     */
    public _delete(requestParameters: CategoryServiceApiDeleteRequest, options?: RawAxiosRequestConfig) {
        return CategoryServiceApiFp(this.configuration)._delete(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can add a subcategory to a category
     * @summary Add a subcategory to a category
     * @param {CategoryServiceApiAddSubCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryServiceApi
     */
    public addSubCategory(requestParameters: CategoryServiceApiAddSubCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryServiceApiFp(this.configuration).addSubCategory(requestParameters.id, requestParameters.categoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can create a category
     * @summary Create a category
     * @param {CategoryServiceApiCreate3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryServiceApi
     */
    public create3(requestParameters: CategoryServiceApiCreate3Request, options?: RawAxiosRequestConfig) {
        return CategoryServiceApiFp(this.configuration).create3(requestParameters.categoryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can delete a subcategory
     * @summary Delete a subcategory
     * @param {CategoryServiceApiDeleteSubCategoryRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryServiceApi
     */
    public deleteSubCategory(requestParameters: CategoryServiceApiDeleteSubCategoryRequest, options?: RawAxiosRequestConfig) {
        return CategoryServiceApiFp(this.configuration).deleteSubCategory(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Public endpoint returns all categories
     * @summary Get all category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryServiceApi
     */
    public getAll2(options?: RawAxiosRequestConfig) {
        return CategoryServiceApiFp(this.configuration).getAll2(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Public endpoint returns a category
     * @summary Get a category
     * @param {CategoryServiceApiGetById1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryServiceApi
     */
    public getById1(requestParameters: CategoryServiceApiGetById1Request, options?: RawAxiosRequestConfig) {
        return CategoryServiceApiFp(this.configuration).getById1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can update a category
     * @summary Update a category
     * @param {CategoryServiceApiUpdate1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryServiceApi
     */
    public update1(requestParameters: CategoryServiceApiUpdate1Request, options?: RawAxiosRequestConfig) {
        return CategoryServiceApiFp(this.configuration).update1(requestParameters.id, requestParameters.categoryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EmailServiceApi - axios parameter creator
 * @export
 */
export const EmailServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Admins can create a promotion email
         * @summary Create a new promotion email
         * @param {PromotionEmailRequest} promotionEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2: async (promotionEmailRequest: PromotionEmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'promotionEmailRequest' is not null or undefined
            assertParamExists('create2', 'promotionEmailRequest', promotionEmailRequest)
            const localVarPath = `/api/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(promotionEmailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can delete a promotion email
         * @summary Delete a promotion email
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('delete2', 'id', id)
            const localVarPath = `/api/email/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can a promotion email
         * @summary Get a promotion email
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('get', 'id', id)
            const localVarPath = `/api/email/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can get all promotion email
         * @summary Get all promotion email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can try out and test a promotion email
         * @summary Try out promotion email
         * @param {string} id 
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (id: string, emailRequest: EmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('test', 'id', id)
            // verify required parameter 'emailRequest' is not null or undefined
            assertParamExists('test', 'emailRequest', emailRequest)
            const localVarPath = `/api/email/test/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailServiceApi - functional programming interface
 * @export
 */
export const EmailServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmailServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Admins can create a promotion email
         * @summary Create a new promotion email
         * @param {PromotionEmailRequest} promotionEmailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create2(promotionEmailRequest: PromotionEmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionEmailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create2(promotionEmailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailServiceApi.create2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can delete a promotion email
         * @summary Delete a promotion email
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailServiceApi.delete2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can a promotion email
         * @summary Get a promotion email
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PromotionEmailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailServiceApi.get']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can get all promotion email
         * @summary Get all promotion email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromotionEmailResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailServiceApi.getAll1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can try out and test a promotion email
         * @summary Try out promotion email
         * @param {string} id 
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(id: string, emailRequest: EmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(id, emailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmailServiceApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmailServiceApi - factory interface
 * @export
 */
export const EmailServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmailServiceApiFp(configuration)
    return {
        /**
         * Admins can create a promotion email
         * @summary Create a new promotion email
         * @param {EmailServiceApiCreate2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create2(requestParameters: EmailServiceApiCreate2Request, options?: RawAxiosRequestConfig): AxiosPromise<PromotionEmailResponse> {
            return localVarFp.create2(requestParameters.promotionEmailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can delete a promotion email
         * @summary Delete a promotion email
         * @param {EmailServiceApiDelete2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete2(requestParameters: EmailServiceApiDelete2Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can a promotion email
         * @summary Get a promotion email
         * @param {EmailServiceApiGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(requestParameters: EmailServiceApiGetRequest, options?: RawAxiosRequestConfig): AxiosPromise<PromotionEmailResponse> {
            return localVarFp.get(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can get all promotion email
         * @summary Get all promotion email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll1(options?: RawAxiosRequestConfig): AxiosPromise<Array<PromotionEmailResponse>> {
            return localVarFp.getAll1(options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can try out and test a promotion email
         * @summary Try out promotion email
         * @param {EmailServiceApiTestRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(requestParameters: EmailServiceApiTestRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.test(requestParameters.id, requestParameters.emailRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for create2 operation in EmailServiceApi.
 * @export
 * @interface EmailServiceApiCreate2Request
 */
export interface EmailServiceApiCreate2Request {
    /**
     * 
     * @type {PromotionEmailRequest}
     * @memberof EmailServiceApiCreate2
     */
    readonly promotionEmailRequest: PromotionEmailRequest
}

/**
 * Request parameters for delete2 operation in EmailServiceApi.
 * @export
 * @interface EmailServiceApiDelete2Request
 */
export interface EmailServiceApiDelete2Request {
    /**
     * 
     * @type {string}
     * @memberof EmailServiceApiDelete2
     */
    readonly id: string
}

/**
 * Request parameters for get operation in EmailServiceApi.
 * @export
 * @interface EmailServiceApiGetRequest
 */
export interface EmailServiceApiGetRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailServiceApiGet
     */
    readonly id: string
}

/**
 * Request parameters for test operation in EmailServiceApi.
 * @export
 * @interface EmailServiceApiTestRequest
 */
export interface EmailServiceApiTestRequest {
    /**
     * 
     * @type {string}
     * @memberof EmailServiceApiTest
     */
    readonly id: string

    /**
     * 
     * @type {EmailRequest}
     * @memberof EmailServiceApiTest
     */
    readonly emailRequest: EmailRequest
}

/**
 * EmailServiceApi - object-oriented interface
 * @export
 * @class EmailServiceApi
 * @extends {BaseAPI}
 */
export class EmailServiceApi extends BaseAPI {
    /**
     * Admins can create a promotion email
     * @summary Create a new promotion email
     * @param {EmailServiceApiCreate2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailServiceApi
     */
    public create2(requestParameters: EmailServiceApiCreate2Request, options?: RawAxiosRequestConfig) {
        return EmailServiceApiFp(this.configuration).create2(requestParameters.promotionEmailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can delete a promotion email
     * @summary Delete a promotion email
     * @param {EmailServiceApiDelete2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailServiceApi
     */
    public delete2(requestParameters: EmailServiceApiDelete2Request, options?: RawAxiosRequestConfig) {
        return EmailServiceApiFp(this.configuration).delete2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can a promotion email
     * @summary Get a promotion email
     * @param {EmailServiceApiGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailServiceApi
     */
    public get(requestParameters: EmailServiceApiGetRequest, options?: RawAxiosRequestConfig) {
        return EmailServiceApiFp(this.configuration).get(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can get all promotion email
     * @summary Get all promotion email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailServiceApi
     */
    public getAll1(options?: RawAxiosRequestConfig) {
        return EmailServiceApiFp(this.configuration).getAll1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can try out and test a promotion email
     * @summary Try out promotion email
     * @param {EmailServiceApiTestRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailServiceApi
     */
    public test(requestParameters: EmailServiceApiTestRequest, options?: RawAxiosRequestConfig) {
        return EmailServiceApiFp(this.configuration).test(requestParameters.id, requestParameters.emailRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ImageServiceApi - axios parameter creator
 * @export
 */
export const ImageServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Public endpoint returns an image by id and extension
         * @summary Get an image
         * @param {string} id 
         * @param {string} fileExtension 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3: async (id: string, fileExtension: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById3', 'id', id)
            // verify required parameter 'fileExtension' is not null or undefined
            assertParamExists('getById3', 'fileExtension', fileExtension)
            const localVarPath = `/api/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (fileExtension !== undefined) {
                localVarQueryParameter['fileExtension'] = fileExtension;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageServiceApi - functional programming interface
 * @export
 */
export const ImageServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Public endpoint returns an image by id and extension
         * @summary Get an image
         * @param {string} id 
         * @param {string} fileExtension 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById3(id: string, fileExtension: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById3(id, fileExtension, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ImageServiceApi.getById3']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ImageServiceApi - factory interface
 * @export
 */
export const ImageServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageServiceApiFp(configuration)
    return {
        /**
         * Public endpoint returns an image by id and extension
         * @summary Get an image
         * @param {ImageServiceApiGetById3Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById3(requestParameters: ImageServiceApiGetById3Request, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getById3(requestParameters.id, requestParameters.fileExtension, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getById3 operation in ImageServiceApi.
 * @export
 * @interface ImageServiceApiGetById3Request
 */
export interface ImageServiceApiGetById3Request {
    /**
     * 
     * @type {string}
     * @memberof ImageServiceApiGetById3
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ImageServiceApiGetById3
     */
    readonly fileExtension: string
}

/**
 * ImageServiceApi - object-oriented interface
 * @export
 * @class ImageServiceApi
 * @extends {BaseAPI}
 */
export class ImageServiceApi extends BaseAPI {
    /**
     * Public endpoint returns an image by id and extension
     * @summary Get an image
     * @param {ImageServiceApiGetById3Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageServiceApi
     */
    public getById3(requestParameters: ImageServiceApiGetById3Request, options?: RawAxiosRequestConfig) {
        return ImageServiceApiFp(this.configuration).getById3(requestParameters.id, requestParameters.fileExtension, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrderServiceApi - axios parameter creator
 * @export
 */
export const OrderServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Users can cancel an order
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('cancel', 'id', id)
            const localVarPath = `/api/order/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admins can update order status
         * @summary Update order status
         * @param {string} id 
         * @param {OrderStatusRequest} orderStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOrderStatus: async (id: string, orderStatusRequest: OrderStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('changeOrderStatus', 'id', id)
            // verify required parameter 'orderStatusRequest' is not null or undefined
            assertParamExists('changeOrderStatus', 'orderStatusRequest', orderStatusRequest)
            const localVarPath = `/api/order/{id}/status`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can create an order
         * @summary Create an order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/order/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin can refund order items
         * @summary Admin can refund order items
         * @param {string} id 
         * @param {Array<RefundOrderItemRequest>} refundOrderItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund: async (id: string, refundOrderItemRequest: Array<RefundOrderItemRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createRefund', 'id', id)
            // verify required parameter 'refundOrderItemRequest' is not null or undefined
            assertParamExists('createRefund', 'refundOrderItemRequest', refundOrderItemRequest)
            const localVarPath = `/api/order/{id}/refund`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refundOrderItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Export orders from a base64 encoded csv
         * @summary Export orders from a csv
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        export1: async (from?: string, to?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/order/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin can get all orders
         * @summary Get all orders
         * @param {string} [minDate] 
         * @param {string} [maxDate] 
         * @param {number} [minPrice] 
         * @param {number} [maxPrice] 
         * @param {Array<GetAll4PaymentMethodsEnum>} [paymentMethods] 
         * @param {Array<GetAll4StatusesEnum>} [statuses] 
         * @param {GetAll4SortTypeEnum} [sortType] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll4: async (minDate?: string, maxDate?: string, minPrice?: number, maxPrice?: number, paymentMethods?: Array<GetAll4PaymentMethodsEnum>, statuses?: Array<GetAll4StatusesEnum>, sortType?: GetAll4SortTypeEnum, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (minDate !== undefined) {
                localVarQueryParameter['minDate'] = (minDate as any instanceof Date) ?
                    (minDate as any).toISOString().substring(0,10) :
                    minDate;
            }

            if (maxDate !== undefined) {
                localVarQueryParameter['maxDate'] = (maxDate as any instanceof Date) ?
                    (maxDate as any).toISOString().substring(0,10) :
                    maxDate;
            }

            if (minPrice !== undefined) {
                localVarQueryParameter['minPrice'] = minPrice;
            }

            if (maxPrice !== undefined) {
                localVarQueryParameter['maxPrice'] = maxPrice;
            }

            if (paymentMethods) {
                localVarQueryParameter['paymentMethods'] = paymentMethods;
            }

            if (statuses) {
                localVarQueryParameter['statuses'] = statuses;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin can get an order by id
         * @summary Get an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById2', 'id', id)
            const localVarPath = `/api/order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can pay an order
         * @summary Pay an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIntent: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('paymentIntent', 'id', id)
            const localVarPath = `/api/order/{id}/paymentIntent`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can return order items
         * @summary Return order items
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnOrder: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('returnOrder', 'id', id)
            const localVarPath = `/api/order/{id}/return`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderServiceApi - functional programming interface
 * @export
 */
export const OrderServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Users can cancel an order
         * @summary Cancel an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancel(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancel(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderServiceApi.cancel']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admins can update order status
         * @summary Update order status
         * @param {string} id 
         * @param {OrderStatusRequest} orderStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeOrderStatus(id: string, orderStatusRequest: OrderStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeOrderStatus(id, orderStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderServiceApi.changeOrderStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Users can create an order
         * @summary Create an order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderServiceApi.create1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin can refund order items
         * @summary Admin can refund order items
         * @param {string} id 
         * @param {Array<RefundOrderItemRequest>} refundOrderItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createRefund(id: string, refundOrderItemRequest: Array<RefundOrderItemRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createRefund(id, refundOrderItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderServiceApi.createRefund']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Export orders from a base64 encoded csv
         * @summary Export orders from a csv
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async export1(from?: string, to?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CsvResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.export1(from, to, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderServiceApi.export1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin can get all orders
         * @summary Get all orders
         * @param {string} [minDate] 
         * @param {string} [maxDate] 
         * @param {number} [minPrice] 
         * @param {number} [maxPrice] 
         * @param {Array<GetAll4PaymentMethodsEnum>} [paymentMethods] 
         * @param {Array<GetAll4StatusesEnum>} [statuses] 
         * @param {GetAll4SortTypeEnum} [sortType] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll4(minDate?: string, maxDate?: string, minPrice?: number, maxPrice?: number, paymentMethods?: Array<GetAll4PaymentMethodsEnum>, statuses?: Array<GetAll4StatusesEnum>, sortType?: GetAll4SortTypeEnum, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderPageOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll4(minDate, maxDate, minPrice, maxPrice, paymentMethods, statuses, sortType, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderServiceApi.getAll4']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin can get an order by id
         * @summary Get an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById2(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById2(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderServiceApi.getById2']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Users can pay an order
         * @summary Pay an order
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async paymentIntent(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaymentIntentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.paymentIntent(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderServiceApi.paymentIntent']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Users can return order items
         * @summary Return order items
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async returnOrder(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.returnOrder(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['OrderServiceApi.returnOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * OrderServiceApi - factory interface
 * @export
 */
export const OrderServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderServiceApiFp(configuration)
    return {
        /**
         * Users can cancel an order
         * @summary Cancel an order
         * @param {OrderServiceApiCancelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancel(requestParameters: OrderServiceApiCancelRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.cancel(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Admins can update order status
         * @summary Update order status
         * @param {OrderServiceApiChangeOrderStatusRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeOrderStatus(requestParameters: OrderServiceApiChangeOrderStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.changeOrderStatus(requestParameters.id, requestParameters.orderStatusRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can create an order
         * @summary Create an order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create1(options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.create1(options).then((request) => request(axios, basePath));
        },
        /**
         * Admin can refund order items
         * @summary Admin can refund order items
         * @param {OrderServiceApiCreateRefundRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefund(requestParameters: OrderServiceApiCreateRefundRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.createRefund(requestParameters.id, requestParameters.refundOrderItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Export orders from a base64 encoded csv
         * @summary Export orders from a csv
         * @param {OrderServiceApiExport1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        export1(requestParameters: OrderServiceApiExport1Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<CsvResponse> {
            return localVarFp.export1(requestParameters.from, requestParameters.to, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin can get all orders
         * @summary Get all orders
         * @param {OrderServiceApiGetAll4Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll4(requestParameters: OrderServiceApiGetAll4Request = {}, options?: RawAxiosRequestConfig): AxiosPromise<OrderPageOrderResponse> {
            return localVarFp.getAll4(requestParameters.minDate, requestParameters.maxDate, requestParameters.minPrice, requestParameters.maxPrice, requestParameters.paymentMethods, requestParameters.statuses, requestParameters.sortType, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Admin can get an order by id
         * @summary Get an order
         * @param {OrderServiceApiGetById2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById2(requestParameters: OrderServiceApiGetById2Request, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.getById2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can pay an order
         * @summary Pay an order
         * @param {OrderServiceApiPaymentIntentRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paymentIntent(requestParameters: OrderServiceApiPaymentIntentRequest, options?: RawAxiosRequestConfig): AxiosPromise<PaymentIntentResponse> {
            return localVarFp.paymentIntent(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can return order items
         * @summary Return order items
         * @param {OrderServiceApiReturnOrderRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        returnOrder(requestParameters: OrderServiceApiReturnOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<OrderResponse> {
            return localVarFp.returnOrder(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for cancel operation in OrderServiceApi.
 * @export
 * @interface OrderServiceApiCancelRequest
 */
export interface OrderServiceApiCancelRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiCancel
     */
    readonly id: string
}

/**
 * Request parameters for changeOrderStatus operation in OrderServiceApi.
 * @export
 * @interface OrderServiceApiChangeOrderStatusRequest
 */
export interface OrderServiceApiChangeOrderStatusRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiChangeOrderStatus
     */
    readonly id: string

    /**
     * 
     * @type {OrderStatusRequest}
     * @memberof OrderServiceApiChangeOrderStatus
     */
    readonly orderStatusRequest: OrderStatusRequest
}

/**
 * Request parameters for createRefund operation in OrderServiceApi.
 * @export
 * @interface OrderServiceApiCreateRefundRequest
 */
export interface OrderServiceApiCreateRefundRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiCreateRefund
     */
    readonly id: string

    /**
     * 
     * @type {Array<RefundOrderItemRequest>}
     * @memberof OrderServiceApiCreateRefund
     */
    readonly refundOrderItemRequest: Array<RefundOrderItemRequest>
}

/**
 * Request parameters for export1 operation in OrderServiceApi.
 * @export
 * @interface OrderServiceApiExport1Request
 */
export interface OrderServiceApiExport1Request {
    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiExport1
     */
    readonly from?: string

    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiExport1
     */
    readonly to?: string
}

/**
 * Request parameters for getAll4 operation in OrderServiceApi.
 * @export
 * @interface OrderServiceApiGetAll4Request
 */
export interface OrderServiceApiGetAll4Request {
    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiGetAll4
     */
    readonly minDate?: string

    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiGetAll4
     */
    readonly maxDate?: string

    /**
     * 
     * @type {number}
     * @memberof OrderServiceApiGetAll4
     */
    readonly minPrice?: number

    /**
     * 
     * @type {number}
     * @memberof OrderServiceApiGetAll4
     */
    readonly maxPrice?: number

    /**
     * 
     * @type {Array<'STRIPE'>}
     * @memberof OrderServiceApiGetAll4
     */
    readonly paymentMethods?: Array<GetAll4PaymentMethodsEnum>

    /**
     * 
     * @type {Array<'CREATED' | 'PAYMENT_FAILED' | 'PAID' | 'PROCESSING' | 'PACKAGED' | 'SHIPPING' | 'DELIVERED' | 'COMPLETED' | 'CANCELLED' | 'WAITING_FOR_REFUND' | 'REFUNDED' | 'RETURN_REQUESTED' | 'RETURN_APPROVED' | 'RETURN_RECEIVED' | 'RETURN_COMPLETED' | 'RETURN_REJECTED'>}
     * @memberof OrderServiceApiGetAll4
     */
    readonly statuses?: Array<GetAll4StatusesEnum>

    /**
     * 
     * @type {'ASC_ORDER_DATE' | 'DESC_ORDER_DATE' | 'ASC_PRICE' | 'DESC_PRICE'}
     * @memberof OrderServiceApiGetAll4
     */
    readonly sortType?: GetAll4SortTypeEnum

    /**
     * 
     * @type {number}
     * @memberof OrderServiceApiGetAll4
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof OrderServiceApiGetAll4
     */
    readonly size?: number
}

/**
 * Request parameters for getById2 operation in OrderServiceApi.
 * @export
 * @interface OrderServiceApiGetById2Request
 */
export interface OrderServiceApiGetById2Request {
    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiGetById2
     */
    readonly id: string
}

/**
 * Request parameters for paymentIntent operation in OrderServiceApi.
 * @export
 * @interface OrderServiceApiPaymentIntentRequest
 */
export interface OrderServiceApiPaymentIntentRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiPaymentIntent
     */
    readonly id: string
}

/**
 * Request parameters for returnOrder operation in OrderServiceApi.
 * @export
 * @interface OrderServiceApiReturnOrderRequest
 */
export interface OrderServiceApiReturnOrderRequest {
    /**
     * 
     * @type {string}
     * @memberof OrderServiceApiReturnOrder
     */
    readonly id: string
}

/**
 * OrderServiceApi - object-oriented interface
 * @export
 * @class OrderServiceApi
 * @extends {BaseAPI}
 */
export class OrderServiceApi extends BaseAPI {
    /**
     * Users can cancel an order
     * @summary Cancel an order
     * @param {OrderServiceApiCancelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public cancel(requestParameters: OrderServiceApiCancelRequest, options?: RawAxiosRequestConfig) {
        return OrderServiceApiFp(this.configuration).cancel(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admins can update order status
     * @summary Update order status
     * @param {OrderServiceApiChangeOrderStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public changeOrderStatus(requestParameters: OrderServiceApiChangeOrderStatusRequest, options?: RawAxiosRequestConfig) {
        return OrderServiceApiFp(this.configuration).changeOrderStatus(requestParameters.id, requestParameters.orderStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can create an order
     * @summary Create an order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public create1(options?: RawAxiosRequestConfig) {
        return OrderServiceApiFp(this.configuration).create1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin can refund order items
     * @summary Admin can refund order items
     * @param {OrderServiceApiCreateRefundRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public createRefund(requestParameters: OrderServiceApiCreateRefundRequest, options?: RawAxiosRequestConfig) {
        return OrderServiceApiFp(this.configuration).createRefund(requestParameters.id, requestParameters.refundOrderItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Export orders from a base64 encoded csv
     * @summary Export orders from a csv
     * @param {OrderServiceApiExport1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public export1(requestParameters: OrderServiceApiExport1Request = {}, options?: RawAxiosRequestConfig) {
        return OrderServiceApiFp(this.configuration).export1(requestParameters.from, requestParameters.to, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin can get all orders
     * @summary Get all orders
     * @param {OrderServiceApiGetAll4Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public getAll4(requestParameters: OrderServiceApiGetAll4Request = {}, options?: RawAxiosRequestConfig) {
        return OrderServiceApiFp(this.configuration).getAll4(requestParameters.minDate, requestParameters.maxDate, requestParameters.minPrice, requestParameters.maxPrice, requestParameters.paymentMethods, requestParameters.statuses, requestParameters.sortType, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin can get an order by id
     * @summary Get an order
     * @param {OrderServiceApiGetById2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public getById2(requestParameters: OrderServiceApiGetById2Request, options?: RawAxiosRequestConfig) {
        return OrderServiceApiFp(this.configuration).getById2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can pay an order
     * @summary Pay an order
     * @param {OrderServiceApiPaymentIntentRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public paymentIntent(requestParameters: OrderServiceApiPaymentIntentRequest, options?: RawAxiosRequestConfig) {
        return OrderServiceApiFp(this.configuration).paymentIntent(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can return order items
     * @summary Return order items
     * @param {OrderServiceApiReturnOrderRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderServiceApi
     */
    public returnOrder(requestParameters: OrderServiceApiReturnOrderRequest, options?: RawAxiosRequestConfig) {
        return OrderServiceApiFp(this.configuration).returnOrder(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAll4PaymentMethodsEnum = {
    Stripe: 'STRIPE'
} as const;
export type GetAll4PaymentMethodsEnum = typeof GetAll4PaymentMethodsEnum[keyof typeof GetAll4PaymentMethodsEnum];
/**
 * @export
 */
export const GetAll4StatusesEnum = {
    Created: 'CREATED',
    PaymentFailed: 'PAYMENT_FAILED',
    Paid: 'PAID',
    Processing: 'PROCESSING',
    Packaged: 'PACKAGED',
    Shipping: 'SHIPPING',
    Delivered: 'DELIVERED',
    Completed: 'COMPLETED',
    Cancelled: 'CANCELLED',
    WaitingForRefund: 'WAITING_FOR_REFUND',
    Refunded: 'REFUNDED',
    ReturnRequested: 'RETURN_REQUESTED',
    ReturnApproved: 'RETURN_APPROVED',
    ReturnReceived: 'RETURN_RECEIVED',
    ReturnCompleted: 'RETURN_COMPLETED',
    ReturnRejected: 'RETURN_REJECTED'
} as const;
export type GetAll4StatusesEnum = typeof GetAll4StatusesEnum[keyof typeof GetAll4StatusesEnum];
/**
 * @export
 */
export const GetAll4SortTypeEnum = {
    AscOrderDate: 'ASC_ORDER_DATE',
    DescOrderDate: 'DESC_ORDER_DATE',
    AscPrice: 'ASC_PRICE',
    DescPrice: 'DESC_PRICE'
} as const;
export type GetAll4SortTypeEnum = typeof GetAll4SortTypeEnum[keyof typeof GetAll4SortTypeEnum];


/**
 * ProductServiceApi - axios parameter creator
 * @export
 */
export const ProductServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Export products to a base64 encoded csv
         * @summary Export products to a csv
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {Array<string>} [brands] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [subCategories] 
         * @param {Array<ExportGendersEnum>} [genders] 
         * @param {number} [maxPrice] 
         * @param {number} [minPrice] 
         * @param {number} [maxDiscountPercentage] 
         * @param {number} [minDiscountPercentage] 
         * @param {string} [itemNumber] 
         * @param {boolean} [showOutOfStock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export: async (from?: string, to?: string, brands?: Array<string>, categories?: Array<string>, subCategories?: Array<string>, genders?: Array<ExportGendersEnum>, maxPrice?: number, minPrice?: number, maxDiscountPercentage?: number, minDiscountPercentage?: number, itemNumber?: string, showOutOfStock?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/product/export`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }

            if (brands) {
                localVarQueryParameter['brands'] = brands;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (subCategories) {
                localVarQueryParameter['subCategories'] = subCategories;
            }

            if (genders) {
                localVarQueryParameter['genders'] = genders;
            }

            if (maxPrice !== undefined) {
                localVarQueryParameter['maxPrice'] = maxPrice;
            }

            if (minPrice !== undefined) {
                localVarQueryParameter['minPrice'] = minPrice;
            }

            if (maxDiscountPercentage !== undefined) {
                localVarQueryParameter['maxDiscountPercentage'] = maxDiscountPercentage;
            }

            if (minDiscountPercentage !== undefined) {
                localVarQueryParameter['minDiscountPercentage'] = minDiscountPercentage;
            }

            if (itemNumber !== undefined) {
                localVarQueryParameter['itemNumber'] = itemNumber;
            }

            if (showOutOfStock !== undefined) {
                localVarQueryParameter['showOutOfStock'] = showOutOfStock;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new product
         * @summary Create product
         * @param {string} brand 
         * @param {string} name 
         * @param {string} description 
         * @param {string} subCategoryId 
         * @param {CreateGenderEnum} gender 
         * @param {number} count 
         * @param {number} price 
         * @param {number} discountPercentage 
         * @param {string} itemNumber 
         * @param {Array<File>} [images] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create: async (brand: string, name: string, description: string, subCategoryId: string, gender: CreateGenderEnum, count: number, price: number, discountPercentage: number, itemNumber: string, images?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'brand' is not null or undefined
            assertParamExists('create', 'brand', brand)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('create', 'name', name)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('create', 'description', description)
            // verify required parameter 'subCategoryId' is not null or undefined
            assertParamExists('create', 'subCategoryId', subCategoryId)
            // verify required parameter 'gender' is not null or undefined
            assertParamExists('create', 'gender', gender)
            // verify required parameter 'count' is not null or undefined
            assertParamExists('create', 'count', count)
            // verify required parameter 'price' is not null or undefined
            assertParamExists('create', 'price', price)
            // verify required parameter 'discountPercentage' is not null or undefined
            assertParamExists('create', 'discountPercentage', discountPercentage)
            // verify required parameter 'itemNumber' is not null or undefined
            assertParamExists('create', 'itemNumber', itemNumber)
            const localVarPath = `/api/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (brand !== undefined) { 
                localVarFormParams.append('brand', brand as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (subCategoryId !== undefined) { 
                localVarFormParams.append('subCategoryId', subCategoryId as any);
            }
    
            if (gender !== undefined) { 
                localVarFormParams.append('gender', gender as any);
            }
    
            if (count !== undefined) { 
                localVarFormParams.append('count', count as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (discountPercentage !== undefined) { 
                localVarFormParams.append('discountPercentage', discountPercentage as any);
            }
                if (images) {
                images.forEach((element) => {
                    localVarFormParams.append('images', element as any);
                })
            }

    
            if (itemNumber !== undefined) { 
                localVarFormParams.append('itemNumber', itemNumber as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete products with id list
         * @summary Delete products with id list
         * @param {DeleteProductRequest} deleteProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1: async (deleteProductRequest: DeleteProductRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteProductRequest' is not null or undefined
            assertParamExists('delete1', 'deleteProductRequest', deleteProductRequest)
            const localVarPath = `/api/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteProductRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all existing products
         * @summary Get all products
         * @param {Array<string>} [brands] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [subCategories] 
         * @param {Array<GetAllGendersEnum>} [genders] 
         * @param {number} [maxPrice] 
         * @param {number} [minPrice] 
         * @param {number} [maxDiscountPercentage] 
         * @param {number} [minDiscountPercentage] 
         * @param {string} [itemNumber] 
         * @param {boolean} [showOutOfStock] 
         * @param {GetAllSortTypeEnum} [sortType] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll: async (brands?: Array<string>, categories?: Array<string>, subCategories?: Array<string>, genders?: Array<GetAllGendersEnum>, maxPrice?: number, minPrice?: number, maxDiscountPercentage?: number, minDiscountPercentage?: number, itemNumber?: string, showOutOfStock?: boolean, sortType?: GetAllSortTypeEnum, page?: number, size?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (brands) {
                localVarQueryParameter['brands'] = brands;
            }

            if (categories) {
                localVarQueryParameter['categories'] = categories;
            }

            if (subCategories) {
                localVarQueryParameter['subCategories'] = subCategories;
            }

            if (genders) {
                localVarQueryParameter['genders'] = genders;
            }

            if (maxPrice !== undefined) {
                localVarQueryParameter['maxPrice'] = maxPrice;
            }

            if (minPrice !== undefined) {
                localVarQueryParameter['minPrice'] = minPrice;
            }

            if (maxDiscountPercentage !== undefined) {
                localVarQueryParameter['maxDiscountPercentage'] = maxDiscountPercentage;
            }

            if (minDiscountPercentage !== undefined) {
                localVarQueryParameter['minDiscountPercentage'] = minDiscountPercentage;
            }

            if (itemNumber !== undefined) {
                localVarQueryParameter['itemNumber'] = itemNumber;
            }

            if (showOutOfStock !== undefined) {
                localVarQueryParameter['showOutOfStock'] = showOutOfStock;
            }

            if (sortType !== undefined) {
                localVarQueryParameter['sortType'] = sortType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Public endpoint, return existing brands
         * @summary Get brands
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrands: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/product/brand`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a products by id
         * @summary Get a products by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById', 'id', id)
            const localVarPath = `/api/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import products from a base64 encoded csv
         * @summary Import products from a csv
         * @param {CsvRequest} csvRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importProducts: async (csvRequest: CsvRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'csvRequest' is not null or undefined
            assertParamExists('importProducts', 'csvRequest', csvRequest)
            const localVarPath = `/api/product/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(csvRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update products discount by id
         * @summary Update products discount by id
         * @param {DiscountRequest} discountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDiscounts: async (discountRequest: DiscountRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'discountRequest' is not null or undefined
            assertParamExists('setDiscounts', 'discountRequest', discountRequest)
            const localVarPath = `/api/product/discount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(discountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a products by id
         * @summary Update a products by id
         * @param {string} id 
         * @param {string} brand 
         * @param {string} name 
         * @param {string} description 
         * @param {string} subCategoryId 
         * @param {UpdateGenderEnum} gender 
         * @param {number} count 
         * @param {number} price 
         * @param {number} discountPercentage 
         * @param {string} itemNumber 
         * @param {Array<File>} [newImages] 
         * @param {Array<string>} [existingImageIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update: async (id: string, brand: string, name: string, description: string, subCategoryId: string, gender: UpdateGenderEnum, count: number, price: number, discountPercentage: number, itemNumber: string, newImages?: Array<File>, existingImageIds?: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('update', 'id', id)
            // verify required parameter 'brand' is not null or undefined
            assertParamExists('update', 'brand', brand)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('update', 'name', name)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('update', 'description', description)
            // verify required parameter 'subCategoryId' is not null or undefined
            assertParamExists('update', 'subCategoryId', subCategoryId)
            // verify required parameter 'gender' is not null or undefined
            assertParamExists('update', 'gender', gender)
            // verify required parameter 'count' is not null or undefined
            assertParamExists('update', 'count', count)
            // verify required parameter 'price' is not null or undefined
            assertParamExists('update', 'price', price)
            // verify required parameter 'discountPercentage' is not null or undefined
            assertParamExists('update', 'discountPercentage', discountPercentage)
            // verify required parameter 'itemNumber' is not null or undefined
            assertParamExists('update', 'itemNumber', itemNumber)
            const localVarPath = `/api/product/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (brand !== undefined) { 
                localVarFormParams.append('brand', brand as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }
    
            if (subCategoryId !== undefined) { 
                localVarFormParams.append('subCategoryId', subCategoryId as any);
            }
    
            if (gender !== undefined) { 
                localVarFormParams.append('gender', gender as any);
            }
    
            if (count !== undefined) { 
                localVarFormParams.append('count', count as any);
            }
    
            if (price !== undefined) { 
                localVarFormParams.append('price', price as any);
            }
    
            if (discountPercentage !== undefined) { 
                localVarFormParams.append('discountPercentage', discountPercentage as any);
            }
                if (newImages) {
                newImages.forEach((element) => {
                    localVarFormParams.append('newImages', element as any);
                })
            }

                if (existingImageIds) {
                localVarFormParams.append('existingImageIds', existingImageIds.join(COLLECTION_FORMATS.csv));
            }

    
            if (itemNumber !== undefined) { 
                localVarFormParams.append('itemNumber', itemNumber as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductServiceApi - functional programming interface
 * @export
 */
export const ProductServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Export products to a base64 encoded csv
         * @summary Export products to a csv
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {Array<string>} [brands] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [subCategories] 
         * @param {Array<ExportGendersEnum>} [genders] 
         * @param {number} [maxPrice] 
         * @param {number} [minPrice] 
         * @param {number} [maxDiscountPercentage] 
         * @param {number} [minDiscountPercentage] 
         * @param {string} [itemNumber] 
         * @param {boolean} [showOutOfStock] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _export(from?: string, to?: string, brands?: Array<string>, categories?: Array<string>, subCategories?: Array<string>, genders?: Array<ExportGendersEnum>, maxPrice?: number, minPrice?: number, maxDiscountPercentage?: number, minDiscountPercentage?: number, itemNumber?: string, showOutOfStock?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CsvResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._export(from, to, brands, categories, subCategories, genders, maxPrice, minPrice, maxDiscountPercentage, minDiscountPercentage, itemNumber, showOutOfStock, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductServiceApi._export']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Create a new product
         * @summary Create product
         * @param {string} brand 
         * @param {string} name 
         * @param {string} description 
         * @param {string} subCategoryId 
         * @param {CreateGenderEnum} gender 
         * @param {number} count 
         * @param {number} price 
         * @param {number} discountPercentage 
         * @param {string} itemNumber 
         * @param {Array<File>} [images] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async create(brand: string, name: string, description: string, subCategoryId: string, gender: CreateGenderEnum, count: number, price: number, discountPercentage: number, itemNumber: string, images?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.create(brand, name, description, subCategoryId, gender, count, price, discountPercentage, itemNumber, images, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductServiceApi.create']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete products with id list
         * @summary Delete products with id list
         * @param {DeleteProductRequest} deleteProductRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async delete1(deleteProductRequest: DeleteProductRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.delete1(deleteProductRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductServiceApi.delete1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get all existing products
         * @summary Get all products
         * @param {Array<string>} [brands] 
         * @param {Array<string>} [categories] 
         * @param {Array<string>} [subCategories] 
         * @param {Array<GetAllGendersEnum>} [genders] 
         * @param {number} [maxPrice] 
         * @param {number} [minPrice] 
         * @param {number} [maxDiscountPercentage] 
         * @param {number} [minDiscountPercentage] 
         * @param {string} [itemNumber] 
         * @param {boolean} [showOutOfStock] 
         * @param {GetAllSortTypeEnum} [sortType] 
         * @param {number} [page] 
         * @param {number} [size] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAll(brands?: Array<string>, categories?: Array<string>, subCategories?: Array<string>, genders?: Array<GetAllGendersEnum>, maxPrice?: number, minPrice?: number, maxDiscountPercentage?: number, minDiscountPercentage?: number, itemNumber?: string, showOutOfStock?: boolean, sortType?: GetAllSortTypeEnum, page?: number, size?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductPageProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAll(brands, categories, subCategories, genders, maxPrice, minPrice, maxDiscountPercentage, minDiscountPercentage, itemNumber, showOutOfStock, sortType, page, size, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductServiceApi.getAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Public endpoint, return existing brands
         * @summary Get brands
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBrands(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<BrandResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBrands(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductServiceApi.getBrands']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get a products by id
         * @summary Get a products by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductServiceApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Import products from a base64 encoded csv
         * @summary Import products from a csv
         * @param {CsvRequest} csvRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importProducts(csvRequest: CsvRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importProducts(csvRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductServiceApi.importProducts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update products discount by id
         * @summary Update products discount by id
         * @param {DiscountRequest} discountRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDiscounts(discountRequest: DiscountRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setDiscounts(discountRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductServiceApi.setDiscounts']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a products by id
         * @summary Update a products by id
         * @param {string} id 
         * @param {string} brand 
         * @param {string} name 
         * @param {string} description 
         * @param {string} subCategoryId 
         * @param {UpdateGenderEnum} gender 
         * @param {number} count 
         * @param {number} price 
         * @param {number} discountPercentage 
         * @param {string} itemNumber 
         * @param {Array<File>} [newImages] 
         * @param {Array<string>} [existingImageIds] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async update(id: string, brand: string, name: string, description: string, subCategoryId: string, gender: UpdateGenderEnum, count: number, price: number, discountPercentage: number, itemNumber: string, newImages?: Array<File>, existingImageIds?: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.update(id, brand, name, description, subCategoryId, gender, count, price, discountPercentage, itemNumber, newImages, existingImageIds, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductServiceApi.update']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductServiceApi - factory interface
 * @export
 */
export const ProductServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductServiceApiFp(configuration)
    return {
        /**
         * Export products to a base64 encoded csv
         * @summary Export products to a csv
         * @param {ProductServiceApiExportRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _export(requestParameters: ProductServiceApiExportRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<CsvResponse> {
            return localVarFp._export(requestParameters.from, requestParameters.to, requestParameters.brands, requestParameters.categories, requestParameters.subCategories, requestParameters.genders, requestParameters.maxPrice, requestParameters.minPrice, requestParameters.maxDiscountPercentage, requestParameters.minDiscountPercentage, requestParameters.itemNumber, requestParameters.showOutOfStock, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new product
         * @summary Create product
         * @param {ProductServiceApiCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        create(requestParameters: ProductServiceApiCreateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.create(requestParameters.brand, requestParameters.name, requestParameters.description, requestParameters.subCategoryId, requestParameters.gender, requestParameters.count, requestParameters.price, requestParameters.discountPercentage, requestParameters.itemNumber, requestParameters.images, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete products with id list
         * @summary Delete products with id list
         * @param {ProductServiceApiDelete1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        delete1(requestParameters: ProductServiceApiDelete1Request, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.delete1(requestParameters.deleteProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all existing products
         * @summary Get all products
         * @param {ProductServiceApiGetAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAll(requestParameters: ProductServiceApiGetAllRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<ProductPageProductResponse> {
            return localVarFp.getAll(requestParameters.brands, requestParameters.categories, requestParameters.subCategories, requestParameters.genders, requestParameters.maxPrice, requestParameters.minPrice, requestParameters.maxDiscountPercentage, requestParameters.minDiscountPercentage, requestParameters.itemNumber, requestParameters.showOutOfStock, requestParameters.sortType, requestParameters.page, requestParameters.size, options).then((request) => request(axios, basePath));
        },
        /**
         * Public endpoint, return existing brands
         * @summary Get brands
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBrands(options?: RawAxiosRequestConfig): AxiosPromise<Array<BrandResponse>> {
            return localVarFp.getBrands(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a products by id
         * @summary Get a products by id
         * @param {ProductServiceApiGetByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(requestParameters: ProductServiceApiGetByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.getById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Import products from a base64 encoded csv
         * @summary Import products from a csv
         * @param {ProductServiceApiImportProductsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importProducts(requestParameters: ProductServiceApiImportProductsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.importProducts(requestParameters.csvRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update products discount by id
         * @summary Update products discount by id
         * @param {ProductServiceApiSetDiscountsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDiscounts(requestParameters: ProductServiceApiSetDiscountsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.setDiscounts(requestParameters.discountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a products by id
         * @summary Update a products by id
         * @param {ProductServiceApiUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        update(requestParameters: ProductServiceApiUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<ProductResponse> {
            return localVarFp.update(requestParameters.id, requestParameters.brand, requestParameters.name, requestParameters.description, requestParameters.subCategoryId, requestParameters.gender, requestParameters.count, requestParameters.price, requestParameters.discountPercentage, requestParameters.itemNumber, requestParameters.newImages, requestParameters.existingImageIds, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for _export operation in ProductServiceApi.
 * @export
 * @interface ProductServiceApiExportRequest
 */
export interface ProductServiceApiExportRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiExport
     */
    readonly from?: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiExport
     */
    readonly to?: string

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductServiceApiExport
     */
    readonly brands?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductServiceApiExport
     */
    readonly categories?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductServiceApiExport
     */
    readonly subCategories?: Array<string>

    /**
     * 
     * @type {Array<'MEN' | 'WOMEN' | 'UNISEX'>}
     * @memberof ProductServiceApiExport
     */
    readonly genders?: Array<ExportGendersEnum>

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiExport
     */
    readonly maxPrice?: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiExport
     */
    readonly minPrice?: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiExport
     */
    readonly maxDiscountPercentage?: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiExport
     */
    readonly minDiscountPercentage?: number

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiExport
     */
    readonly itemNumber?: string

    /**
     * 
     * @type {boolean}
     * @memberof ProductServiceApiExport
     */
    readonly showOutOfStock?: boolean
}

/**
 * Request parameters for create operation in ProductServiceApi.
 * @export
 * @interface ProductServiceApiCreateRequest
 */
export interface ProductServiceApiCreateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiCreate
     */
    readonly brand: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiCreate
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiCreate
     */
    readonly description: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiCreate
     */
    readonly subCategoryId: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiCreate
     */
    readonly gender: CreateGenderEnum

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiCreate
     */
    readonly count: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiCreate
     */
    readonly price: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiCreate
     */
    readonly discountPercentage: number

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiCreate
     */
    readonly itemNumber: string

    /**
     * 
     * @type {Array<File>}
     * @memberof ProductServiceApiCreate
     */
    readonly images?: Array<File>
}

/**
 * Request parameters for delete1 operation in ProductServiceApi.
 * @export
 * @interface ProductServiceApiDelete1Request
 */
export interface ProductServiceApiDelete1Request {
    /**
     * 
     * @type {DeleteProductRequest}
     * @memberof ProductServiceApiDelete1
     */
    readonly deleteProductRequest: DeleteProductRequest
}

/**
 * Request parameters for getAll operation in ProductServiceApi.
 * @export
 * @interface ProductServiceApiGetAllRequest
 */
export interface ProductServiceApiGetAllRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductServiceApiGetAll
     */
    readonly brands?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductServiceApiGetAll
     */
    readonly categories?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductServiceApiGetAll
     */
    readonly subCategories?: Array<string>

    /**
     * 
     * @type {Array<'MEN' | 'WOMEN' | 'UNISEX'>}
     * @memberof ProductServiceApiGetAll
     */
    readonly genders?: Array<GetAllGendersEnum>

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiGetAll
     */
    readonly maxPrice?: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiGetAll
     */
    readonly minPrice?: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiGetAll
     */
    readonly maxDiscountPercentage?: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiGetAll
     */
    readonly minDiscountPercentage?: number

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiGetAll
     */
    readonly itemNumber?: string

    /**
     * 
     * @type {boolean}
     * @memberof ProductServiceApiGetAll
     */
    readonly showOutOfStock?: boolean

    /**
     * 
     * @type {'ASC_PRICE' | 'DESC_PRICE' | 'ASC_DISCOUNT' | 'DESC_DISCOUNT'}
     * @memberof ProductServiceApiGetAll
     */
    readonly sortType?: GetAllSortTypeEnum

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiGetAll
     */
    readonly page?: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiGetAll
     */
    readonly size?: number
}

/**
 * Request parameters for getById operation in ProductServiceApi.
 * @export
 * @interface ProductServiceApiGetByIdRequest
 */
export interface ProductServiceApiGetByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiGetById
     */
    readonly id: string
}

/**
 * Request parameters for importProducts operation in ProductServiceApi.
 * @export
 * @interface ProductServiceApiImportProductsRequest
 */
export interface ProductServiceApiImportProductsRequest {
    /**
     * 
     * @type {CsvRequest}
     * @memberof ProductServiceApiImportProducts
     */
    readonly csvRequest: CsvRequest
}

/**
 * Request parameters for setDiscounts operation in ProductServiceApi.
 * @export
 * @interface ProductServiceApiSetDiscountsRequest
 */
export interface ProductServiceApiSetDiscountsRequest {
    /**
     * 
     * @type {DiscountRequest}
     * @memberof ProductServiceApiSetDiscounts
     */
    readonly discountRequest: DiscountRequest
}

/**
 * Request parameters for update operation in ProductServiceApi.
 * @export
 * @interface ProductServiceApiUpdateRequest
 */
export interface ProductServiceApiUpdateRequest {
    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiUpdate
     */
    readonly id: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiUpdate
     */
    readonly brand: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiUpdate
     */
    readonly name: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiUpdate
     */
    readonly description: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiUpdate
     */
    readonly subCategoryId: string

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiUpdate
     */
    readonly gender: UpdateGenderEnum

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiUpdate
     */
    readonly count: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiUpdate
     */
    readonly price: number

    /**
     * 
     * @type {number}
     * @memberof ProductServiceApiUpdate
     */
    readonly discountPercentage: number

    /**
     * 
     * @type {string}
     * @memberof ProductServiceApiUpdate
     */
    readonly itemNumber: string

    /**
     * 
     * @type {Array<File>}
     * @memberof ProductServiceApiUpdate
     */
    readonly newImages?: Array<File>

    /**
     * 
     * @type {Array<string>}
     * @memberof ProductServiceApiUpdate
     */
    readonly existingImageIds?: Array<string>
}

/**
 * ProductServiceApi - object-oriented interface
 * @export
 * @class ProductServiceApi
 * @extends {BaseAPI}
 */
export class ProductServiceApi extends BaseAPI {
    /**
     * Export products to a base64 encoded csv
     * @summary Export products to a csv
     * @param {ProductServiceApiExportRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductServiceApi
     */
    public _export(requestParameters: ProductServiceApiExportRequest = {}, options?: RawAxiosRequestConfig) {
        return ProductServiceApiFp(this.configuration)._export(requestParameters.from, requestParameters.to, requestParameters.brands, requestParameters.categories, requestParameters.subCategories, requestParameters.genders, requestParameters.maxPrice, requestParameters.minPrice, requestParameters.maxDiscountPercentage, requestParameters.minDiscountPercentage, requestParameters.itemNumber, requestParameters.showOutOfStock, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new product
     * @summary Create product
     * @param {ProductServiceApiCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductServiceApi
     */
    public create(requestParameters: ProductServiceApiCreateRequest, options?: RawAxiosRequestConfig) {
        return ProductServiceApiFp(this.configuration).create(requestParameters.brand, requestParameters.name, requestParameters.description, requestParameters.subCategoryId, requestParameters.gender, requestParameters.count, requestParameters.price, requestParameters.discountPercentage, requestParameters.itemNumber, requestParameters.images, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete products with id list
     * @summary Delete products with id list
     * @param {ProductServiceApiDelete1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductServiceApi
     */
    public delete1(requestParameters: ProductServiceApiDelete1Request, options?: RawAxiosRequestConfig) {
        return ProductServiceApiFp(this.configuration).delete1(requestParameters.deleteProductRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all existing products
     * @summary Get all products
     * @param {ProductServiceApiGetAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductServiceApi
     */
    public getAll(requestParameters: ProductServiceApiGetAllRequest = {}, options?: RawAxiosRequestConfig) {
        return ProductServiceApiFp(this.configuration).getAll(requestParameters.brands, requestParameters.categories, requestParameters.subCategories, requestParameters.genders, requestParameters.maxPrice, requestParameters.minPrice, requestParameters.maxDiscountPercentage, requestParameters.minDiscountPercentage, requestParameters.itemNumber, requestParameters.showOutOfStock, requestParameters.sortType, requestParameters.page, requestParameters.size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Public endpoint, return existing brands
     * @summary Get brands
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductServiceApi
     */
    public getBrands(options?: RawAxiosRequestConfig) {
        return ProductServiceApiFp(this.configuration).getBrands(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a products by id
     * @summary Get a products by id
     * @param {ProductServiceApiGetByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductServiceApi
     */
    public getById(requestParameters: ProductServiceApiGetByIdRequest, options?: RawAxiosRequestConfig) {
        return ProductServiceApiFp(this.configuration).getById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import products from a base64 encoded csv
     * @summary Import products from a csv
     * @param {ProductServiceApiImportProductsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductServiceApi
     */
    public importProducts(requestParameters: ProductServiceApiImportProductsRequest, options?: RawAxiosRequestConfig) {
        return ProductServiceApiFp(this.configuration).importProducts(requestParameters.csvRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update products discount by id
     * @summary Update products discount by id
     * @param {ProductServiceApiSetDiscountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductServiceApi
     */
    public setDiscounts(requestParameters: ProductServiceApiSetDiscountsRequest, options?: RawAxiosRequestConfig) {
        return ProductServiceApiFp(this.configuration).setDiscounts(requestParameters.discountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a products by id
     * @summary Update a products by id
     * @param {ProductServiceApiUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductServiceApi
     */
    public update(requestParameters: ProductServiceApiUpdateRequest, options?: RawAxiosRequestConfig) {
        return ProductServiceApiFp(this.configuration).update(requestParameters.id, requestParameters.brand, requestParameters.name, requestParameters.description, requestParameters.subCategoryId, requestParameters.gender, requestParameters.count, requestParameters.price, requestParameters.discountPercentage, requestParameters.itemNumber, requestParameters.newImages, requestParameters.existingImageIds, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ExportGendersEnum = {
    Men: 'MEN',
    Women: 'WOMEN',
    Unisex: 'UNISEX'
} as const;
export type ExportGendersEnum = typeof ExportGendersEnum[keyof typeof ExportGendersEnum];
/**
 * @export
 */
export const CreateGenderEnum = {
    Men: 'MEN',
    Women: 'WOMEN',
    Unisex: 'UNISEX'
} as const;
export type CreateGenderEnum = typeof CreateGenderEnum[keyof typeof CreateGenderEnum];
/**
 * @export
 */
export const GetAllGendersEnum = {
    Men: 'MEN',
    Women: 'WOMEN',
    Unisex: 'UNISEX'
} as const;
export type GetAllGendersEnum = typeof GetAllGendersEnum[keyof typeof GetAllGendersEnum];
/**
 * @export
 */
export const GetAllSortTypeEnum = {
    AscPrice: 'ASC_PRICE',
    DescPrice: 'DESC_PRICE',
    AscDiscount: 'ASC_DISCOUNT',
    DescDiscount: 'DESC_DISCOUNT'
} as const;
export type GetAllSortTypeEnum = typeof GetAllSortTypeEnum[keyof typeof GetAllSortTypeEnum];
/**
 * @export
 */
export const UpdateGenderEnum = {
    Men: 'MEN',
    Women: 'WOMEN',
    Unisex: 'UNISEX'
} as const;
export type UpdateGenderEnum = typeof UpdateGenderEnum[keyof typeof UpdateGenderEnum];


/**
 * StatisticsServiceApi - axios parameter creator
 * @export
 */
export const StatisticsServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Admin can get statistics
         * @summary Get statistics
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [topCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics: async (from?: string, to?: string, topCount?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = (from as any instanceof Date) ?
                    (from as any).toISOString().substring(0,10) :
                    from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = (to as any instanceof Date) ?
                    (to as any).toISOString().substring(0,10) :
                    to;
            }

            if (topCount !== undefined) {
                localVarQueryParameter['topCount'] = topCount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatisticsServiceApi - functional programming interface
 * @export
 */
export const StatisticsServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatisticsServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Admin can get statistics
         * @summary Get statistics
         * @param {string} [from] 
         * @param {string} [to] 
         * @param {number} [topCount] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatistics(from?: string, to?: string, topCount?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatisticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatistics(from, to, topCount, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StatisticsServiceApi.getStatistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StatisticsServiceApi - factory interface
 * @export
 */
export const StatisticsServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatisticsServiceApiFp(configuration)
    return {
        /**
         * Admin can get statistics
         * @summary Get statistics
         * @param {StatisticsServiceApiGetStatisticsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatistics(requestParameters: StatisticsServiceApiGetStatisticsRequest = {}, options?: RawAxiosRequestConfig): AxiosPromise<StatisticsResponse> {
            return localVarFp.getStatistics(requestParameters.from, requestParameters.to, requestParameters.topCount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getStatistics operation in StatisticsServiceApi.
 * @export
 * @interface StatisticsServiceApiGetStatisticsRequest
 */
export interface StatisticsServiceApiGetStatisticsRequest {
    /**
     * 
     * @type {string}
     * @memberof StatisticsServiceApiGetStatistics
     */
    readonly from?: string

    /**
     * 
     * @type {string}
     * @memberof StatisticsServiceApiGetStatistics
     */
    readonly to?: string

    /**
     * 
     * @type {number}
     * @memberof StatisticsServiceApiGetStatistics
     */
    readonly topCount?: number
}

/**
 * StatisticsServiceApi - object-oriented interface
 * @export
 * @class StatisticsServiceApi
 * @extends {BaseAPI}
 */
export class StatisticsServiceApi extends BaseAPI {
    /**
     * Admin can get statistics
     * @summary Get statistics
     * @param {StatisticsServiceApiGetStatisticsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatisticsServiceApi
     */
    public getStatistics(requestParameters: StatisticsServiceApiGetStatisticsRequest = {}, options?: RawAxiosRequestConfig) {
        return StatisticsServiceApiFp(this.configuration).getStatistics(requestParameters.from, requestParameters.to, requestParameters.topCount, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * StoreServiceApi - axios parameter creator
 * @export
 */
export const StoreServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve essential store settings for users
         * @summary Get public store configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicStore: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/store/public`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin can retrieve store configuration
         * @summary Get store configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStore: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Admin can update store configuration
         * @summary Update store configuration
         * @param {StoreRequest} storeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStore: async (storeRequest: StoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'storeRequest' is not null or undefined
            assertParamExists('updateStore', 'storeRequest', storeRequest)
            const localVarPath = `/api/store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreServiceApi - functional programming interface
 * @export
 */
export const StoreServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve essential store settings for users
         * @summary Get public store configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicStore(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicStoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicStore(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreServiceApi.getPublicStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin can retrieve store configuration
         * @summary Get store configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStore(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStore(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreServiceApi.getStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Admin can update store configuration
         * @summary Update store configuration
         * @param {StoreRequest} storeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateStore(storeRequest: StoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StoreResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateStore(storeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StoreServiceApi.updateStore']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StoreServiceApi - factory interface
 * @export
 */
export const StoreServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreServiceApiFp(configuration)
    return {
        /**
         * Retrieve essential store settings for users
         * @summary Get public store configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicStore(options?: RawAxiosRequestConfig): AxiosPromise<PublicStoreResponse> {
            return localVarFp.getPublicStore(options).then((request) => request(axios, basePath));
        },
        /**
         * Admin can retrieve store configuration
         * @summary Get store configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStore(options?: RawAxiosRequestConfig): AxiosPromise<StoreResponse> {
            return localVarFp.getStore(options).then((request) => request(axios, basePath));
        },
        /**
         * Admin can update store configuration
         * @summary Update store configuration
         * @param {StoreServiceApiUpdateStoreRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateStore(requestParameters: StoreServiceApiUpdateStoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<StoreResponse> {
            return localVarFp.updateStore(requestParameters.storeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updateStore operation in StoreServiceApi.
 * @export
 * @interface StoreServiceApiUpdateStoreRequest
 */
export interface StoreServiceApiUpdateStoreRequest {
    /**
     * 
     * @type {StoreRequest}
     * @memberof StoreServiceApiUpdateStore
     */
    readonly storeRequest: StoreRequest
}

/**
 * StoreServiceApi - object-oriented interface
 * @export
 * @class StoreServiceApi
 * @extends {BaseAPI}
 */
export class StoreServiceApi extends BaseAPI {
    /**
     * Retrieve essential store settings for users
     * @summary Get public store configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreServiceApi
     */
    public getPublicStore(options?: RawAxiosRequestConfig) {
        return StoreServiceApiFp(this.configuration).getPublicStore(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin can retrieve store configuration
     * @summary Get store configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreServiceApi
     */
    public getStore(options?: RawAxiosRequestConfig) {
        return StoreServiceApiFp(this.configuration).getStore(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Admin can update store configuration
     * @summary Update store configuration
     * @param {StoreServiceApiUpdateStoreRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreServiceApi
     */
    public updateStore(requestParameters: StoreServiceApiUpdateStoreRequest, options?: RawAxiosRequestConfig) {
        return StoreServiceApiFp(this.configuration).updateStore(requestParameters.storeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserServiceApi - axios parameter creator
 * @export
 */
export const UserServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add items to users saved products
         * @summary Add to saved products
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSaved: async (requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('addSaved', 'requestBody', requestBody)
            const localVarPath = `/api/user/add/saved`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/delete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can request a new password if the old is forgotten
         * @summary New password request
         * @param {ForgottenPasswordRequest} forgottenPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgottenPassword: async (forgottenPasswordRequest: ForgottenPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'forgottenPasswordRequest' is not null or undefined
            assertParamExists('forgottenPassword', 'forgottenPasswordRequest', forgottenPasswordRequest)
            const localVarPath = `/api/user/forgotten/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(forgottenPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the users cart products
         * @summary Get cart products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Current user can be retrieved
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/current`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the orders for the user
         * @summary Get orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the users saved products
         * @summary Get saved products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaved: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user/saved`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User can be retrieved by an id with an admin
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserById', 'id', id)
            const localVarPath = `/api/user/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can be retrieved
         * @summary Get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user password with a new one
         * @summary Update users password
         * @param {NewPasswordRequest} newPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newPassword: async (newPasswordRequest: NewPasswordRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newPasswordRequest' is not null or undefined
            assertParamExists('newPassword', 'newPasswordRequest', newPasswordRequest)
            const localVarPath = `/api/user/new/password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newPasswordRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Users can register with the required information
         * @summary Registration of new user
         * @param {RegistrationRequest} registrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registrationRequest: RegistrationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registrationRequest' is not null or undefined
            assertParamExists('register', 'registrationRequest', registrationRequest)
            const localVarPath = `/api/user/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registrationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove items to users saved products
         * @summary Remove from saved products
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSaved: async (requestBody: Array<string>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('removeSaved', 'requestBody', requestBody)
            const localVarPath = `/api/user/remove/saved`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After registration users can resend the verification email
         * @summary Resend verification email
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerify: async (emailRequest: EmailRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'emailRequest' is not null or undefined
            assertParamExists('resendVerify', 'emailRequest', emailRequest)
            const localVarPath = `/api/user/resend-verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(emailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User can unsubscribe from email list with email
         * @summary Unsubscribe from email list with email
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unSubscribeToEmailListWithId: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('unSubscribeToEmailListWithId', 'id', id)
            const localVarPath = `/api/user/unsubscribe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the users cart products
         * @summary Update cart products
         * @param {Array<CartItemRequest>} cartItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart: async (cartItemRequest: Array<CartItemRequest>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cartItemRequest' is not null or undefined
            assertParamExists('updateCart', 'cartItemRequest', cartItemRequest)
            const localVarPath = `/api/user/update/cart`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cartItemRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a users email and/or username
         * @summary Update user
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserRequest: UpdateUserRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserRequest' is not null or undefined
            assertParamExists('updateUser', 'updateUserRequest', updateUserRequest)
            const localVarPath = `/api/user/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * After registration users must be verified, with a verification link that is given in an email
         * @summary Verify an user
         * @param {VerificationRequest} verificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify: async (verificationRequest: VerificationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verificationRequest' is not null or undefined
            assertParamExists('verify', 'verificationRequest', verificationRequest)
            const localVarPath = `/api/user/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuthentication required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verificationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserServiceApi - functional programming interface
 * @export
 */
export const UserServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Add items to users saved products
         * @summary Add to saved products
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addSaved(requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addSaved(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.addSaved']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Delete a user
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Users can request a new password if the old is forgotten
         * @summary New password request
         * @param {ForgottenPasswordRequest} forgottenPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forgottenPassword(forgottenPasswordRequest: ForgottenPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forgottenPassword(forgottenPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.forgottenPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the users cart products
         * @summary Get cart products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCart(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CartItemResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCart(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.getCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Current user can be retrieved
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the orders for the user
         * @summary Get orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.getOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Get the users saved products
         * @summary Get saved products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSaved(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSaved(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.getSaved']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User can be retrieved by an id with an admin
         * @summary Get user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Users can be retrieved
         * @summary Get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.getUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a user password with a new one
         * @summary Update users password
         * @param {NewPasswordRequest} newPasswordRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newPassword(newPasswordRequest: NewPasswordRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newPassword(newPasswordRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.newPassword']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Users can register with the required information
         * @summary Registration of new user
         * @param {RegistrationRequest} registrationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registrationRequest: RegistrationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registrationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Remove items to users saved products
         * @summary Remove from saved products
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeSaved(requestBody: Array<string>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeSaved(requestBody, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.removeSaved']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * After registration users can resend the verification email
         * @summary Resend verification email
         * @param {EmailRequest} emailRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendVerify(emailRequest: EmailRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendVerify(emailRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.resendVerify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * User can unsubscribe from email list with email
         * @summary Unsubscribe from email list with email
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unSubscribeToEmailListWithId(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unSubscribeToEmailListWithId(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.unSubscribeToEmailListWithId']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the users cart products
         * @summary Update cart products
         * @param {Array<CartItemRequest>} cartItemRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCart(cartItemRequest: Array<CartItemRequest>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CartItemResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCart(cartItemRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.updateCart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update a users email and/or username
         * @summary Update user
         * @param {UpdateUserRequest} updateUserRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserRequest: UpdateUserRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.updateUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * After registration users must be verified, with a verification link that is given in an email
         * @summary Verify an user
         * @param {VerificationRequest} verificationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verify(verificationRequest: VerificationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verify(verificationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserServiceApi.verify']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserServiceApi - factory interface
 * @export
 */
export const UserServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserServiceApiFp(configuration)
    return {
        /**
         * Add items to users saved products
         * @summary Add to saved products
         * @param {UserServiceApiAddSavedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSaved(requestParameters: UserServiceApiAddSavedRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductResponse>> {
            return localVarFp.addSaved(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user
         * @summary Delete user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Users can request a new password if the old is forgotten
         * @summary New password request
         * @param {UserServiceApiForgottenPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forgottenPassword(requestParameters: UserServiceApiForgottenPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.forgottenPassword(requestParameters.forgottenPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the users cart products
         * @summary Get cart products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCart(options?: RawAxiosRequestConfig): AxiosPromise<Array<CartItemResponse>> {
            return localVarFp.getCart(options).then((request) => request(axios, basePath));
        },
        /**
         * Current user can be retrieved
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the orders for the user
         * @summary Get orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(options?: RawAxiosRequestConfig): AxiosPromise<Array<OrderResponse>> {
            return localVarFp.getOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the users saved products
         * @summary Get saved products
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSaved(options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductResponse>> {
            return localVarFp.getSaved(options).then((request) => request(axios, basePath));
        },
        /**
         * User can be retrieved by an id with an admin
         * @summary Get user
         * @param {UserServiceApiGetUserByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(requestParameters: UserServiceApiGetUserByIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.getUserById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can be retrieved
         * @summary Get users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<UserResponse>> {
            return localVarFp.getUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user password with a new one
         * @summary Update users password
         * @param {UserServiceApiNewPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newPassword(requestParameters: UserServiceApiNewPasswordRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.newPassword(requestParameters.newPasswordRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Users can register with the required information
         * @summary Registration of new user
         * @param {UserServiceApiRegisterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(requestParameters: UserServiceApiRegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.register(requestParameters.registrationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove items to users saved products
         * @summary Remove from saved products
         * @param {UserServiceApiRemoveSavedRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeSaved(requestParameters: UserServiceApiRemoveSavedRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<ProductResponse>> {
            return localVarFp.removeSaved(requestParameters.requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * After registration users can resend the verification email
         * @summary Resend verification email
         * @param {UserServiceApiResendVerifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVerify(requestParameters: UserServiceApiResendVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendVerify(requestParameters.emailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User can unsubscribe from email list with email
         * @summary Unsubscribe from email list with email
         * @param {UserServiceApiUnSubscribeToEmailListWithIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unSubscribeToEmailListWithId(requestParameters: UserServiceApiUnSubscribeToEmailListWithIdRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.unSubscribeToEmailListWithId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the users cart products
         * @summary Update cart products
         * @param {UserServiceApiUpdateCartRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCart(requestParameters: UserServiceApiUpdateCartRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<CartItemResponse>> {
            return localVarFp.updateCart(requestParameters.cartItemRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a users email and/or username
         * @summary Update user
         * @param {UserServiceApiUpdateUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(requestParameters: UserServiceApiUpdateUserRequest, options?: RawAxiosRequestConfig): AxiosPromise<UserResponse> {
            return localVarFp.updateUser(requestParameters.updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * After registration users must be verified, with a verification link that is given in an email
         * @summary Verify an user
         * @param {UserServiceApiVerifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verify(requestParameters: UserServiceApiVerifyRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.verify(requestParameters.verificationRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for addSaved operation in UserServiceApi.
 * @export
 * @interface UserServiceApiAddSavedRequest
 */
export interface UserServiceApiAddSavedRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserServiceApiAddSaved
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for forgottenPassword operation in UserServiceApi.
 * @export
 * @interface UserServiceApiForgottenPasswordRequest
 */
export interface UserServiceApiForgottenPasswordRequest {
    /**
     * 
     * @type {ForgottenPasswordRequest}
     * @memberof UserServiceApiForgottenPassword
     */
    readonly forgottenPasswordRequest: ForgottenPasswordRequest
}

/**
 * Request parameters for getUserById operation in UserServiceApi.
 * @export
 * @interface UserServiceApiGetUserByIdRequest
 */
export interface UserServiceApiGetUserByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserServiceApiGetUserById
     */
    readonly id: string
}

/**
 * Request parameters for newPassword operation in UserServiceApi.
 * @export
 * @interface UserServiceApiNewPasswordRequest
 */
export interface UserServiceApiNewPasswordRequest {
    /**
     * 
     * @type {NewPasswordRequest}
     * @memberof UserServiceApiNewPassword
     */
    readonly newPasswordRequest: NewPasswordRequest
}

/**
 * Request parameters for register operation in UserServiceApi.
 * @export
 * @interface UserServiceApiRegisterRequest
 */
export interface UserServiceApiRegisterRequest {
    /**
     * 
     * @type {RegistrationRequest}
     * @memberof UserServiceApiRegister
     */
    readonly registrationRequest: RegistrationRequest
}

/**
 * Request parameters for removeSaved operation in UserServiceApi.
 * @export
 * @interface UserServiceApiRemoveSavedRequest
 */
export interface UserServiceApiRemoveSavedRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserServiceApiRemoveSaved
     */
    readonly requestBody: Array<string>
}

/**
 * Request parameters for resendVerify operation in UserServiceApi.
 * @export
 * @interface UserServiceApiResendVerifyRequest
 */
export interface UserServiceApiResendVerifyRequest {
    /**
     * 
     * @type {EmailRequest}
     * @memberof UserServiceApiResendVerify
     */
    readonly emailRequest: EmailRequest
}

/**
 * Request parameters for unSubscribeToEmailListWithId operation in UserServiceApi.
 * @export
 * @interface UserServiceApiUnSubscribeToEmailListWithIdRequest
 */
export interface UserServiceApiUnSubscribeToEmailListWithIdRequest {
    /**
     * 
     * @type {string}
     * @memberof UserServiceApiUnSubscribeToEmailListWithId
     */
    readonly id: string
}

/**
 * Request parameters for updateCart operation in UserServiceApi.
 * @export
 * @interface UserServiceApiUpdateCartRequest
 */
export interface UserServiceApiUpdateCartRequest {
    /**
     * 
     * @type {Array<CartItemRequest>}
     * @memberof UserServiceApiUpdateCart
     */
    readonly cartItemRequest: Array<CartItemRequest>
}

/**
 * Request parameters for updateUser operation in UserServiceApi.
 * @export
 * @interface UserServiceApiUpdateUserRequest
 */
export interface UserServiceApiUpdateUserRequest {
    /**
     * 
     * @type {UpdateUserRequest}
     * @memberof UserServiceApiUpdateUser
     */
    readonly updateUserRequest: UpdateUserRequest
}

/**
 * Request parameters for verify operation in UserServiceApi.
 * @export
 * @interface UserServiceApiVerifyRequest
 */
export interface UserServiceApiVerifyRequest {
    /**
     * 
     * @type {VerificationRequest}
     * @memberof UserServiceApiVerify
     */
    readonly verificationRequest: VerificationRequest
}

/**
 * UserServiceApi - object-oriented interface
 * @export
 * @class UserServiceApi
 * @extends {BaseAPI}
 */
export class UserServiceApi extends BaseAPI {
    /**
     * Add items to users saved products
     * @summary Add to saved products
     * @param {UserServiceApiAddSavedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public addSaved(requestParameters: UserServiceApiAddSavedRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).addSaved(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user
     * @summary Delete user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public deleteUser(options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).deleteUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can request a new password if the old is forgotten
     * @summary New password request
     * @param {UserServiceApiForgottenPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public forgottenPassword(requestParameters: UserServiceApiForgottenPasswordRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).forgottenPassword(requestParameters.forgottenPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the users cart products
     * @summary Get cart products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public getCart(options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).getCart(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Current user can be retrieved
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the orders for the user
     * @summary Get orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public getOrders(options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).getOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the users saved products
     * @summary Get saved products
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public getSaved(options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).getSaved(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User can be retrieved by an id with an admin
     * @summary Get user
     * @param {UserServiceApiGetUserByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public getUserById(requestParameters: UserServiceApiGetUserByIdRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).getUserById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can be retrieved
     * @summary Get users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public getUsers(options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).getUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user password with a new one
     * @summary Update users password
     * @param {UserServiceApiNewPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public newPassword(requestParameters: UserServiceApiNewPasswordRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).newPassword(requestParameters.newPasswordRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Users can register with the required information
     * @summary Registration of new user
     * @param {UserServiceApiRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public register(requestParameters: UserServiceApiRegisterRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).register(requestParameters.registrationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove items to users saved products
     * @summary Remove from saved products
     * @param {UserServiceApiRemoveSavedRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public removeSaved(requestParameters: UserServiceApiRemoveSavedRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).removeSaved(requestParameters.requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After registration users can resend the verification email
     * @summary Resend verification email
     * @param {UserServiceApiResendVerifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public resendVerify(requestParameters: UserServiceApiResendVerifyRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).resendVerify(requestParameters.emailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User can unsubscribe from email list with email
     * @summary Unsubscribe from email list with email
     * @param {UserServiceApiUnSubscribeToEmailListWithIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public unSubscribeToEmailListWithId(requestParameters: UserServiceApiUnSubscribeToEmailListWithIdRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).unSubscribeToEmailListWithId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the users cart products
     * @summary Update cart products
     * @param {UserServiceApiUpdateCartRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public updateCart(requestParameters: UserServiceApiUpdateCartRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).updateCart(requestParameters.cartItemRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a users email and/or username
     * @summary Update user
     * @param {UserServiceApiUpdateUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public updateUser(requestParameters: UserServiceApiUpdateUserRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).updateUser(requestParameters.updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * After registration users must be verified, with a verification link that is given in an email
     * @summary Verify an user
     * @param {UserServiceApiVerifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserServiceApi
     */
    public verify(requestParameters: UserServiceApiVerifyRequest, options?: RawAxiosRequestConfig) {
        return UserServiceApiFp(this.configuration).verify(requestParameters.verificationRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



